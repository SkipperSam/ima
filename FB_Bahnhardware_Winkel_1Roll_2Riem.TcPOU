<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Bahnhardware_Winkel_1Roll_2Riem" Id="{0cd5184b-11ea-463f-a5a9-a1bf9a1e8341}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Bahnhardware_Winkel_1Roll_2Riem
(*====================================================================================================*)
(*	Modul		:	FB_Hardware_Winkel_1Roll_2Riem								*)
(*	Funktion	:	Aufruf und Versorgung der FB_BahnV2-Bausteine für ein Winkelübergabe mit 	*)
(*				1 Rollen- und 2 Riemensektion									*)
(*				Handling der Positionierung, Geschwindigkeitsermittlung, Protokollierung	*)
(*				Aufträge werden von extern über eine Struktur übergeben				*)
(*	Autor		:	Arnd Schildmeier											*)
(*	Erstellt	: 	13.01.2015												*)
(*====================================================================================================*)
(*					 freigegeben (V)					projektbezogen (P)		*)
(*	SPS				: 	1.0.0							0.0.0				*)
(*===============		Aenderungen	(P)		======================================================*)
(*	V/R/B	|	Autor			|	Datum		| 	Beschreibung					*)
(*===============		Aenderungen	(V)		======================================================*)
(*	V/R/B	|	Autor			|	Datum		| 	Beschreibung					*)


VAR_IN_OUT
	strIO_GHdshk_Roll1:			BahnAustausch;		(* Struktur vom Bahnmodul *)
	strIO_GHdshk_Roll1_Vorg:		BahnAustausch;		(* Struktur vom Bahnmodul vorherige Bahn *)
	strIO_GHdshk_Roll1_Nachf:		BahnAustausch;		(* Struktur vom Bahnmodul nachfolgende Bahn *)
	strIO_GHdshk_Riem1:			BahnAustausch;		(* Struktur vom Bahnmodul *)
	strIO_GHdshk_Riem1_Vorg:		BahnAustausch;		(* Struktur vom Bahnmodul vorherige Bahn *)
	strIO_GHdshk_Riem1_Nachf:		BahnAustausch;		(* Struktur vom Bahnmodul nachfolgende Bahn *)
	strIO_GHdshk_Riem2:			BahnAustausch;		(* Struktur vom Bahnmodul *)
	strIO_GHdshk_Riem2_Vorg:		BahnAustausch;		(* Struktur vom Bahnmodul vorherige Bahn *)
	strIO_GHdshk_Riem2_Nachf:		BahnAustausch;		(* Struktur vom Bahnmodul nachfolgende Bahn *)
	strIO_GLmHand:				strHandfkt;			(* Struktur fuer Leuchttaster *)
	strIO_TrE:					TrE_Daten_All;		(* TrE *)
	strIO_Stoerungen:				strStoerungen; 		(* Fehlervariablen für Leuchtmelder oder Automatik Aus *)
END_VAR
VAR_INPUT
	uiI_ProId:					UINT:=1;		(* ID für Protokollierung *)
	uiI_TrEId:					UINT:=1;		(* ID für TrE und Bahn *)
	uiI_AxId_Roll1:				UINT;			(* ID für Drehgeber, wenn 0, dann Registerimpulszähler *)
	uiI_AxId_Riem1:				UINT;			(* ID für Drehgeber, wenn 0, dann Registerimpulszähler *)
	uiI_AxId_Riem2:				UINT;			(* ID für Drehgeber, wenn 0, dann Registerimpulszähler *)
	uiI_FehlerId_Roll1:			UINT:=1;		(* ID für Fehlermeldungen *)
	uiI_FehlerId_Riem1:			UINT:=1;		(* ID für Fehlermeldungen *)
	uiI_FehlerId_Riem2:			UINT:=1;		(* ID für Fehlermeldungen *)
	sI_Bahnname:				STRING:='Dummy';	(* Name der Sektion, z.B. 27.01.01 *)
	bI_Hand:					BOOL;			(* Hand ist an *)
	bI_Automatik:				BOOL;			(* Automatik ist an *)
	bI_Testbetrieb:				BOOL;			(* Testbetrieb ist aktiv *)
	bI_SicherheitOK:				BOOL;			(* Transport darf drehen *)
	bI_FreigabeAutomatik:			BOOL;			(* Wenn False, werden die Schrittketten angehalten *)
	bI_FreigabeHandVorZurueck_Roll1:	BOOL;			(* Freigabe Bahn in Hand vor oder zurück, Handfunktionsnummer *)
	bI_FreigabeHandVorZurueck_Riem1:	BOOL;			(* Freigabe Bahn in Hand vor oder zurück, Handfunktionsnummer *)
	bI_FreigabeHandVorZurueck_Riem2:	BOOL;			(* Freigabe Bahn in Hand vor oder zurück, Handfunktionsnummer *)
	bI_BahnDarfZurueckHand_Roll1:		BOOL;			(* Bahn darf generell zurueck drehen *)
	bI_BahnDarfZurueckHand_Riem1:		BOOL;			(* Bahn darf generell zurueck drehen *)
	bI_BahnDarfZurueckHand_Riem2:		BOOL;			(* Bahn darf generell zurueck drehen *)
	bI_FreigabeHandHebenSenkenSek1:	BOOL;			(* Freigabe Bahn in Hand heben oder senken, Handfunktionsnummer *)
	bI_FreigabeHandHebenSenkenSek2:	BOOL;			(* Freigabe Bahn in Hand heben oder senken, Handfunktionsnummer *)
	bI_FreigabeReset:				BOOL;			(* Freigabe Bahn Reset auslösen, Handfunktionsnummer *)
	bI_StoerungAntrieb_Roll1:		BOOL;			(* Antrieb ist auf Störung *)
	bI_Anfang_Roll1:				BOOL;			(* Anfang der Bahn *)
	bI_Ende_Roll1:				BOOL;			(* Ende der Bahn *)
	bI_AufFoerderhoehe_Roll1: 		BOOL;			(* Bahn ist auf Förderhöhe *)
	bI_StoerungAntrieb_Riem1:		BOOL;			(* Antrieb ist auf Störung *)
	bI_Anfang_Riem1:				BOOL;			(* Anfang der Bahn *)
	bI_Ende_Riem1:				BOOL;			(* Ende der Bahn *)
	bI_AufFoerderhoehe_Riem1: 		BOOL;			(* Bahn ist auf Förderhöhe *)
	bI_StoerungAntrieb_Riem2:		BOOL;			(* Antrieb ist auf Störung *)
	bI_Anfang_Riem2:				BOOL;			(* Anfang der Bahn *)
	bI_Ende_Riem2:				BOOL;			(* Ende der Bahn *)
	bI_AufFoerderhoehe_Riem2: 		BOOL;			(* Bahn ist auf Förderhöhe *)
	bI_HebenSenkenInvers: 			BOOL;			(* FALSE: Riemenbahn steuert hoch/runter, TRUE: Rollenbahn steuert *)
	bI_VorZurueckInversHand: 		BOOL;			(* Vor und Zurueck bei Handfunktionen invers *)
	bI_AbbruchPosi_AufBahn_Roll1:		BOOL;			(* Positionierung abbrechen und fertig melden *)
	bI_AbbruchPosi_AufBahn_Riem1:		BOOL;			(* Positionierung abbrechen und fertig melden *)
	bI_AbbruchPosi_AufBahn_Riem2:		BOOL;			(* Positionierung abbrechen und fertig melden *)
	bI_AbbruchPosi_VonBahn_Roll1:		BOOL;			(* Positionierung abbrechen und fertig melden *)
	bI_AbbruchPosi_VonBahn_Riem1:		BOOL;			(* Positionierung abbrechen und fertig melden *)
	bI_AbbruchPosi_VonBahn_Riem2:		BOOL;			(* Positionierung abbrechen und fertig melden *)
	bI_BahnenGrundSchnell_Sek_1:		BOOL;			(* wenn keine Daten auf der Bahn sind, dann schnell die Grundstellungsfahrt machen *)
	bI_BahnenGrundSchnell_Sek_2:		BOOL;			(* wenn keine Daten auf der Bahn sind, dann schnell die Grundstellungsfahrt machen *)
	bI_HubGrundWennFrei_Sek_1:		BOOL;			(* wenn True, dann wird der Hub in Grundstellung gefahren, wenn Bahn leer *)
	bI_HubGrundWennFrei_Sek_2:		BOOL;			(* wenn True, dann wird der Hub in Grundstellung gefahren, wenn Bahn leer *)
	bI_HubArbeitWennFrei_Sek_1:		BOOL;			(* wenn True, dann wird der Hub in Arbeitstellung gefahren, wenn Bahn leer *)
	bI_HubArbeitWennFrei_Sek_2:		BOOL;			(* wenn True, dann wird der Hub in Arbeitstellung gefahren, wenn Bahn leer *)
	bI_HubGrundWennBelegt_Sek_1:		BOOL;			(* wenn True, dann wird der Hub in Grundstellung gefahren, wenn Bahn belegt *)
	bI_HubGrundWennBelegt_Sek_2:		BOOL;			(* wenn True, dann wird der Hub in Grundstellung gefahren, wenn Bahn beleg *)
	bI_HubArbeitWennBelegt_Sek_1:		BOOL;			(* wenn True, dann wird der Hub in Arbeitstellung gefahren, wenn Bahn belegt *)
	bI_HubArbeitWennBelegt_Sek_2:		BOOL;			(* wenn True, dann wird der Hub in Arbeitstellung gefahren, wenn Bahn belegt *)
	bI_OhneSynchronVonBahn_Roll1:		BOOL;			(* Die Geschwindigkeit der Zielbahn nicht übernehmen *)
	bI_OhneSynchronVonBahn_Riem1:		BOOL;			(* Die Geschwindigkeit der Zielbahn nicht übernehmen *)
	bI_OhneSynchronVonBahn_Riem2:		BOOL;			(* Die Geschwindigkeit der Zielbahn nicht übernehmen *)
	bI_VorgRiemHatNurEineSpur:		BOOL;			(* Die vorherige Riemenbahn hat nur eine Spur *)
	bI_NachfRiemHatNurEineSpur:		BOOL;			(* Die nachfolgende Riemenbahn hat nur eine Spur *)
	bI_MitUeberwachungTeilNichtFreigegeben: BOOL;		(* Ueberwachung deaktivieren *)
	bI_ImpulsInit:				BOOL;			(* Impuls von außen, dass alles neu Initialisiert wird *)
	bI_OhneImpulsgeber_Roll1:		BOOL;			(* Kein Registerimpuls und kein Drehgeber vorhanden. Impulse werden dann simuliert *)
	bI_OhneImpulsgeber_Riem1:		BOOL;			(* Kein Registerimpuls und kein Drehgeber vorhanden. Impulse werden dann simuliert *)
	bI_OhneImpulsgeber_Riem2:		BOOL;			(* Kein Registerimpuls und kein Drehgeber vorhanden. Impulse werden dann simuliert *)
END_VAR

VAR_OUTPUT
	bQ_Sektion1AS:				BOOL;			(* Transport Rollen 1 auf Förderhöhe fahren *)
	bQ_Sektion1GS:				BOOL;			(* Transport Riemen 1 auf Förderhöhe fahren *)
	bQ_Sektion2AS:				BOOL;			(* Transport Rollen 1 auf Förderhöhe fahren *)
	bQ_Sektion2GS:				BOOL;			(* Transport Riemen 2 auf Förderhöhe fahren *)
END_VAR

VAR
	fbBahn_Roll1:				FB_BahnV2;
	fbBahn_Riem1:				FB_BahnV2;
	fbBahn_Riem2:				FB_BahnV2;

	fbGeberHandling_AufBahn_Roll1:	FB_GeberHandling_Posi;
	fbGeberHandling_VonBahn_Roll1:	FB_GeberHandling_Posi;
	fbGeberHandling_PosPlatte_Roll1:	FB_GeberHandling_Position_Platte;
	fbGeberHandling_AufBahn_Riem1:	FB_GeberHandling_Posi;
	fbGeberHandling_VonBahn_Riem1:	FB_GeberHandling_Posi;
	fbGeberHandling_PosPlatte_Riem1:	FB_GeberHandling_Position_Platte;
	fbGeberHandling_AufBahn_Riem2:	FB_GeberHandling_Posi;
	fbGeberHandling_VonBahn_Riem2:	FB_GeberHandling_Posi;
	fbGeberHandling_PosPlatte_Riem2:	FB_GeberHandling_Position_Platte;

	fbVirtuellerImpulsgeber_Roll1:	FB_VirtuellerImpulsgeber;
	fbVirtuellerImpulsgeber_Riem1:	FB_VirtuellerImpulsgeber;
	fbVirtuellerImpulsgeber_Riem2:	FB_VirtuellerImpulsgeber;
	fbGeberKontrolle_Roll1:			FB_KontrolleStreckenzaehler;
	fbGeberKontrolle_Riem1:			FB_KontrolleStreckenzaehler;
	fbGeberKontrolle_Riem2:			FB_KontrolleStreckenzaehler;
	fbAxIstwert_Roll1:			FB_EncoderAchse_MC2;
	fbAxIstwert_Riem1:			FB_EncoderAchse_MC2;
	fbAxIstwert_Riem2:			FB_EncoderAchse_MC2;
	fbRampe_Roll1:				G_0100_VeloController;
	fbRampe_Riem1:				G_0100_VeloController;
	fbRampe_Riem2:				G_0100_VeloController;

	lrZyklusZeit_SPS:				LREAL;
	fbGetTaskID:				GETCURTASKINDEX;

	fbEntprellenBelegtkontrolle_Roll1:	FB_Entprellen;
	fbEntprellenBelegtkontrolle_Riem1:	FB_Entprellen;
	fbEntprellenBelegtkontrolle_Riem2:	FB_Entprellen;
	fbEntprellenAnfang_Roll1:		FB_Entprellen;
	fbEntprellenAnfang_Riem1:		FB_Entprellen;
	fbEntprellenAnfang_Riem2:		FB_Entprellen;
	fbEntprellenVorAnfang_Roll1:		FB_Entprellen;
	fbEntprellenVorAnfang_Riem1:		FB_Entprellen;
	fbEntprellenVorAnfang_Riem2:		FB_Entprellen;
	fbEntprellenEnde_Roll1:			FB_Entprellen;
	fbEntprellenEnde_Riem1:			FB_Entprellen;
	fbEntprellenEnde_Riem2:			FB_Entprellen;
	fbEntprellenVorEnde_Roll1:		FB_Entprellen;
	fbEntprellenVorEnde_Riem1:		FB_Entprellen;
	fbEntprellenVorEnde_Riem2:		FB_Entprellen;

	iLast_Sket1_Roll1:			INT;
	iLast_Sket2_Roll1:			INT;
	iLast_Speed_Roll1:			INT;
	iLast_Sket1_Riem1:			INT;
	iLast_Sket2_Riem1:			INT;
	iLast_Speed_Riem1:			INT;
	iLast_Sket1_Riem2:			INT;
	iLast_Sket2_Riem2:			INT;
	iLast_Speed_Riem2:			INT;
	bLast_Anfang_Roll1:			BOOL;
	bLast_Belegt_Roll1:			BOOL;
	bLast_Ende_Roll1:				BOOL;
	bLast_Vorlauf_Roll1:			BOOL;
	bLast_Zurueck_Roll1:			BOOL;
	bLast_Anfang_Riem1:			BOOL;
	bLast_Belegt_Riem1:			BOOL;
	bLast_Ende_Riem1:				BOOL;
	bLast_Vorlauf_Riem1:			BOOL;
	bLast_Zurueck_Riem1:			BOOL;
	bLast_Anfang_Riem2:			BOOL;
	bLast_Belegt_Riem2:			BOOL;
	bLast_Ende_Riem2:				BOOL;
	bLast_Vorlauf_Riem2:			BOOL;
	bLast_Zurueck_Riem2:			BOOL;
	bHandHebenSenkenAktiv_Sek_1:		BOOL;
	bHandHebenSenkenAktiv_Sek_2:		BOOL;
	bProto_BahnInGrund_Roll1:		BOOL;
	bProto_BahnInGrund_Riem1:		BOOL;
	bProto_BahnInGrund_Riem2:		BOOL;
	bIstwertSetzen_Roll1:			BOOL;
	bIstwertSetzen_Riem1:			BOOL;
	bIstwertSetzen_Riem2:			BOOL;
	bInit:					BOOL;
	bSwAnfang_Roll1:				BOOL;
	bSwAnfang_Riem1:				BOOL;
	bSwAnfang_Riem2:				BOOL;
	bSwVorAnfang_Roll1:			BOOL;
	bSwVorAnfang_Riem1:			BOOL;
	bSwVorAnfang_Riem2:			BOOL;
	bSwEnde_Roll1:				BOOL;
	bSwEnde_Riem1:				BOOL;
	bSwEnde_Riem2:				BOOL;
	bSwVorEnde_Roll1:				BOOL;
	bSwVorEnde_Riem1:				BOOL;
	bSwVorEnde_Riem2:				BOOL;
	bBahnBelegt:				BOOL;

	iIncGeberZaehler_Roll1:			INT;
	iIncGeberZaehler_Riem1:			INT;
	iIncGeberZaehler_Riem2:			INT;
	iBahnLetzteBewegung_Sek_1:		INT;
	iBahnLetzteBewegung_Sek_2:		INT;

	lrIstwert_Bahn_Roll1:			LREAL;
	lrIstwert_Bahn_Riem1:			LREAL;
	lrIstwert_Bahn_Riem2:			LREAL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Aufruf																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
IF NOT bInit
	OR	bI_ImpulsInit
THEN
	strIO_TrE.sName:= CONCAT(sGText[eText_Winkeluebergabe],' ');
	strIO_TrE.sName:= CONCAT(strIO_TrE.sName, sI_Bahnname);

	strIO_GHdshk_Roll1.ui_TrEId:= uiI_TrEId;
	strIO_GHdshk_Roll1.di_PlatzId:= gkPlatzId[uiI_TrEId];
	strIO_GHdshk_Roll1.s_Name:= CONCAT(sGText[eText_Rollen],' ');
	strIO_GHdshk_Roll1.s_Name:= CONCAT(strIO_GHdshk_Roll1.s_Name, sI_Bahnname);

	strIO_GHdshk_Riem1.ui_TrEId:= uiI_TrEId;
	strIO_GHdshk_Riem1.di_PlatzId:= gkPlatzId[uiI_TrEId];
	strIO_GHdshk_Riem1.s_Name:= CONCAT(sGText[eText_Riemen],' ');
	strIO_GHdshk_Riem1.s_Name:= CONCAT(strIO_GHdshk_Riem1.s_Name, sI_Bahnname);

	strIO_GHdshk_Riem2.ui_TrEId:= uiI_TrEId;
	strIO_GHdshk_Riem2.di_PlatzId:= gkPlatzId[uiI_TrEId];
	strIO_GHdshk_Riem2.s_Name:= CONCAT(sGText[eText_Riemen],' ');
	strIO_GHdshk_Riem2.s_Name:= CONCAT(strIO_GHdshk_Riem2.s_Name, sI_Bahnname);

	bInit:= TRUE;
END_IF;

fbGetTaskID();

IF	lrZyklusZeit_SPS=0
	AND	fbGetTaskID.index > 0
THEN
	lrZyklusZeit_SPS:= ( UDINT_TO_LREAL(_TaskInfo[fbGetTaskID.index].CycleTime) / 10000000 );
END_IF;

fbEntprellenBelegtkontrolle_Roll1(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell,
	tEntprell_Frei:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell,
	OsSensor=> );

fbEntprellenAnfang_Roll1(
	IsSensor:= bI_Anfang_Roll1
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_AnfangBelegt,
	tEntprell_Frei:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_AnfangFrei,
	OsSensor=> );

fbEntprellenVorAnfang_Roll1(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_AnfangBelegt,
	tEntprell_Frei:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_AnfangFrei,
	OsSensor=> );

fbEntprellenEnde_Roll1(
	IsSensor:= bI_Ende_Roll1
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_EndeBelegt,
	tEntprell_Frei:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_EndeFrei,
	OsSensor=> );

fbEntprellenVorEnde_Roll1(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_EndeBelegt,
	tEntprell_Frei:= strIO_GHdshk_Roll1.str_BahnZeiten.tEntprell_EndeFrei,
	OsSensor=> );

fbEntprellenBelegtkontrolle_Riem1(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell,
	tEntprell_Frei:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell,
	OsSensor=> );

fbEntprellenAnfang_Riem1(
	IsSensor:= bI_Anfang_Riem1
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_AnfangBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_AnfangFrei,
	OsSensor=> );

fbEntprellenVorAnfang_Riem1(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_AnfangBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_AnfangFrei,
	OsSensor=> );

fbEntprellenEnde_Riem1(
	IsSensor:= bI_Ende_Riem1
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_EndeBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_EndeFrei,
	OsSensor=> );

fbEntprellenVorEnde_Riem1(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_EndeBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem1.str_BahnZeiten.tEntprell_EndeFrei,
	OsSensor=> );

fbEntprellenBelegtkontrolle_Riem2(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell,
	tEntprell_Frei:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell,
	OsSensor=> );

fbEntprellenAnfang_Riem2(
	IsSensor:= bI_Anfang_Riem2
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_AnfangBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_AnfangFrei,
	OsSensor=> );

fbEntprellenVorAnfang_Riem2(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_AnfangBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_AnfangFrei,
	OsSensor=> );

fbEntprellenEnde_Riem2(
	IsSensor:= bI_Ende_Riem2
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_EndeBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_EndeFrei,
	OsSensor=> );

fbEntprellenVorEnde_Riem2(
	IsSensor:= FALSE
			AND NOT bI_Testbetrieb,
	tEntprell_Belegt:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_EndeBelegt,
	tEntprell_Frei:= strIO_GHdshk_Riem2.str_BahnZeiten.tEntprell_EndeFrei,
	OsSensor=> );

A_Bahnmodi_Roll1();
A_Bahnmodi_Riem1();
A_Bahnmodi_Riem2();

B_Zeiten_Rampen_Speed_Roll1();
B_Zeiten_Rampen_Speed_Riem1();
B_Zeiten_Rampen_Speed_Riem2();

C_Eingaenge_Roll1();
C_Eingaenge_Riem1();
C_Eingaenge_Riem2();

D_Bahnjob_Roll1();
D_Bahnjob_Riem1();
D_Bahnjob_Riem2();

bBahnBelegt:= strIO_GHdshk_Roll1.b_BahnBelegt
		OR	strIO_GHdshk_Riem1.b_BahnBelegt
		OR	strIO_GHdshk_Riem2.b_BahnBelegt;


fbBahn_Roll1( IO_Belegt:= bBahnBelegt,
			IO_Tre_Daten:= strIO_TrE );

fbBahn_Riem1( IO_Belegt:= bBahnBelegt,
			IO_Tre_Daten:= strIO_TrE );

fbBahn_Riem2( IO_Belegt:= bBahnBelegt,
			IO_Tre_Daten:= strIO_TrE);

strIO_GHdshk_Riem1.b_BahnBelegt:=
strIO_GHdshk_Riem2.b_BahnBelegt:=
strIO_GHdshk_Roll1.b_BahnBelegt:=
	bBahnBelegt;

E_Ausgaenge_Roll1();
E_Ausgaenge_Riem1();
E_Ausgaenge_Riem2();
E_Ausgaenge_Hub();

iIncGeberZaehler_Roll1:= giIncGeberZaehler[uiI_TrEId,1];		(* Impulse aus der schnellen Task holen und auswerten *)
giIncGeberZaehler[uiI_TrEId,1]:= 0;

iIncGeberZaehler_Riem1:= giIncGeberZaehler[uiI_TrEId,2];		(* Impulse aus der schnellen Task holen und auswerten *)
giIncGeberZaehler[uiI_TrEId,2]:= 0;

iIncGeberZaehler_Riem2:= giIncGeberZaehler[uiI_TrEId,3];		(* Impulse aus der schnellen Task holen und auswerten *)
giIncGeberZaehler[uiI_TrEId,3]:= 0;

F_Positionierung_Roll1();
F_Positionierung_Riem1();
F_Positionierung_Riem2();

G_Protokoll_Roll1();
G_Protokoll_Riem1();
G_Protokoll_Riem2();

H_Funktionsauswertung_Roll1();
H_Funktionsauswertung_Riem1();
H_Funktionsauswertung_Riem2();
H_Funktionsauswertung_Verriegelung();

I_TrEstati_Diagnose();

Y_Struktur_Roll1();
Y_Struktur_Riem1();
Y_Struktur_Riem2();

Z_Meldungen_Roll1();
Z_Meldungen_Riem1();
Z_Meldungen_Riem2();]]></ST>
    </Implementation>
    <Action Name="A_Bahnmodi_Riem1" Id="{2fff4163-e318-40b7-a96e-915cb6bb6784}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*	Anhand der einzelnen Bahnmodi wird dem Transportbaustein 'FB_BahnV2' übergeben, wie er die Teile fahren soll			*)
(*	weitere Erläuterungen zu den einzelnen Bahnmodi sind in 'FB_BahnV2.Up01_Versionen' und der Struktur 'Bahnmode' zu finden	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

(* Angeschlossene Zusatzmodule *)
fbBahn_Riem1.IwBahnMode.xUserInterfaceAktiv							:= TRUE;		(* Bei Laufzeitüberwachung gibt es eine Dialogbox für den Bediener, F_Dialogbox + P_Handling_DialogBox + Struktur 'User_Interface' + 3Tec notwendig *)

(* Modi der Bahn: Überwachungszeit/Laufzeit *)
IF	strIO_GHdshk_Riem1_Vorg.b_ExterneBahn
	AND ( strIO_GHdshk_Riem1.str_JobAktiv_AufBahn = eRolljobAufBahnVorlauf
			OR	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf )
	OR	strIO_GHdshk_Riem1_Nachf.b_ExterneBahn
	AND ( strIO_GHdshk_Riem1.str_JobAktiv_AufBahn = eRolljobAufBahnRuecklauf
			OR	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf )
THEN
	fbBahn_Riem1.IwBahnMode.xOhneUeberwachungszeit_AufBahn				:= TRUE;		(* Die maximale Laufzeit einer Platte auf die Bahn wird NICHT überwacht *)
ELSE

	fbBahn_Riem1.IwBahnMode.xOhneUeberwachungszeit_AufBahn				:= FALSE;		(* Die maximale Laufzeit einer Platte auf die Bahn wird überwacht *)
END_IF;

IF	strIO_GHdshk_Riem1_Nachf.b_ExterneBahn
	AND ( strIO_GHdshk_Riem1.str_JobAktiv_VonBahn = eRolljobVonBahnVorlauf
			OR	strIO_GHdshk_Riem1.str_JobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf )
	OR	strIO_GHdshk_Riem1_Vorg.b_ExterneBahn
	AND ( strIO_GHdshk_Riem1.str_JobAktiv_VonBahn = eRolljobVonBahnRuecklauf
			OR	strIO_GHdshk_Riem1.str_JobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf )
THEN
	fbBahn_Riem1.IwBahnMode.xOhneUeberwachungszeit_VonBahn				:= TRUE;		(* Die maximale Laufzeit einer Platte von der Bahn wird NICHT überwacht *)
ELSE
	fbBahn_Riem1.IwBahnMode.xOhneUeberwachungszeit_VonBahn				:= FALSE;		(* Die maximale Laufzeit einer Platte von der Bahn wird überwacht *)
END_IF;

fbBahn_Riem1.IwBahnMode.xOhneUeberwachungszeit_AufBahn_AnEndeAnfang			:= FALSE;		(* Laufzeitüberwachung bei Job AufBahn bei 'eRolljobAnsBahnendeVorlauf' oder 'eRolljobAnBahnanfangRuecklauf' *)
fbBahn_Riem1.IwBahnMode.xOhneUeberwachungszeit_VonBahn_AnEndeAnfang			:= FALSE;		(* Laufzeitüberwachung bei Job VonBahn bei 'eRolljobAnsBahnendeVorlauf' oder 'eRolljobAnBahnanfangRuecklauf' *)

fbBahn_Riem1.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitLeer			:= TRUE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' leer gemeldet *)
fbBahn_Riem1.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitWeiter		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' im Ablauf weiter gemacht *)
fbBahn_Riem1.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitNochmal		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' der Ablauf wiederholt *)

fbBahn_Riem1.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitLeer			:= TRUE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' leer gemeldet *)
fbBahn_Riem1.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitWeiter		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' im Ablauf weiter gemacht *)
fbBahn_Riem1.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitNochmal		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' der Ablauf wiederholt *)

(* Modi der Bahn: Positionierungsjobs, z.B. eRolljobAufBahnPosiVorlauf *)
fbBahn_Riem1.IwBahnMode.xAufBahnPosi_AnfangBeachten						:= strIO_GHdshk_Riem1.str_JobAktiv_AufBahn <> eRolljobAufBahnMittigVorlauf	(* Die Positionierung wird erst mit gestartet, wenn Teil in Anfang bzw. Ende bei Rücklauf ist *)
															AND	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn <> eRolljobAufBahnMittigRuecklauf;
fbBahn_Riem1.IwBahnMode.xAufBahnPosi_StopBeiEnde						:= FALSE;		(* Die Positionierung wird abgebrochen, wenn Teil in Ende bzw. Anfang bei Rücklauf ist *)
fbBahn_Riem1.IwBahnMode.xAufBahnPosi_StopBeiEnde_MitFehler					:= FALSE;		(* Fehler ausgeben, wenn Positionierung abgebrochen wird *)

(* Modi der Bahn: Jobs ohne Positionierung, z.B. eRolljobAufBahnVorlauf *)
fbBahn_Riem1.IwBahnMode.xAufBahnVorlauf_StopMitHK						:= TRUE;		(* Beim Job AufBahn im Vorlauf mit HK stehen bleiben und nicht ins Ende durchfahren *)
fbBahn_Riem1.IwBahnMode.xAufBahnVorlauf_NachlaufAmBahnende					:= FALSE;		(* Beim Job AufBahn 'eRolljobAufBahnVorlauf' wird bei Ende eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Riem1.IwBahnMode.xAnsBahnende_MitNachlauf						:= FALSE;		(* Beim Job 'eRolljobAnsBahnendeVorlauf' wird bei Ende eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Riem1.IwBahnMode.xStopMitHK_UeberWeg							:= TRUE;		(* Der Weg Stop mit HK wird über eine Strecke angegeben, sonst Zeit *)
fbBahn_Riem1.IwBahnMode.xNachlaufUebergabe_UeberWeg						:= FALSE;		(* Beim Job VonBahn wird der Nachlauf über einen Weg gemacht, sonst Zeit *)

fbBahn_Riem1.IwBahnMode.xAufBahnRuecklauf_StopMitHK						:= TRUE;		(* Beim Job AufBahn im Rücklauf mit HK stehen bleiben und nicht in Anfang durchfahren *)
fbBahn_Riem1.IwBahnMode.xAufBahnRuecklauf_NachlaufAmBahnanfang				:= FALSE;		(* Beim Job AufBahn 'eRolljobAufBahnRuecklauf' wird bei Anfang eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Riem1.IwBahnMode.xAnBahnanfang_MitNachlauf						:= FALSE;		(* Beim Job 'eRolljobAnBahnanfangRuecklauf' wird bei Anfang eine Nachlaufzeit gestartet -> ausrichten *)

(* Modi der Bahn: Grundstellungsfahrt *)
IF 	strIO_TrE.iAnzahlPlatten > 0												(* es gibt noch Platten auf der Bahn *)
	AND	strIO_TrE.asBarcode[1] <> ''											(* Daten vorhanden *)
	OR	fbBahn_Roll1.IsAnfangBahn											(* Teil im Uebergang *)
		AND	strIO_GHdshk_Roll1_Vorg.b_LiEnde
		AND 	iBahnLetzteBewegung_Sek_1 = 2
	OR	fbBahn_Roll1.IsEndeBahn
		AND	strIO_GHdshk_Roll1_Nachf.b_LiAnfang
		AND 	iBahnLetzteBewegung_Sek_1 = 1
	OR	fbBahn_Riem1.IsAnfangBahn
		AND	strIO_GHdshk_Riem1_Vorg.b_LiEnde
		AND 	iBahnLetzteBewegung_Sek_1 = 12
	OR	fbBahn_Riem1.IsEndeBahn
		AND	strIO_GHdshk_Riem1_Nachf.b_LiAnfang
		AND 	iBahnLetzteBewegung_Sek_1 = 11
THEN
	fbBahn_Riem1.IwBahnMode.iFahrtInGrund							:= eGrund_BelegtMelden;
	fbBahn_Riem1.IwBahnMode.xDatenPruefen_NachGrund						:= FALSE;		(* Nach Fahrt in Grund wird die Hardwarebelegung mit den Daten verglichen *)
ELSE
	fbBahn_Riem1.IwBahnMode.iFahrtInGrund							:= eGrund_FreiMelden;
	fbBahn_Riem1.IwBahnMode.xDatenPruefen_NachGrund						:= TRUE;		(* Nach Fahrt in Grund wird die Hardwarebelegung mit den Daten verglichen *)
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_Bahnmodi_Riem2" Id="{9c64007d-6ae3-488d-bd4f-fe7f101304d0}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*	Anhand der einzelnen Bahnmodi wird dem Transportbaustein 'FB_BahnV2' übergeben, wie er die Teile fahren soll			*)
(*	weitere Erläuterungen zu den einzelnen Bahnmodi sind in 'FB_BahnV2.Up01_Versionen' und der Struktur 'Bahnmode' zu finden	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

(* Angeschlossene Zusatzmodule *)
fbBahn_Riem2.IwBahnMode.xUserInterfaceAktiv							:= TRUE;		(* Bei Laufzeitüberwachung gibt es eine Dialogbox für den Bediener, F_Dialogbox + P_Handling_DialogBox + Struktur 'User_Interface' + 3Tec notwendig *)

(* Modi der Bahn: Überwachungszeit/Laufzeit *)
IF ( strIO_GHdshk_Riem2_Vorg.b_ExterneBahn
	AND NOT bI_VorgRiemHatNurEineSpur
	OR	strIO_GHdshk_Riem1_Vorg.b_ExterneBahn
		AND 	bI_VorgRiemHatNurEineSpur )
	AND ( strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnVorlauf
			OR	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf )
	OR ( strIO_GHdshk_Riem2_Nachf.b_ExterneBahn
		AND NOT bI_NachfRiemHatNurEineSpur
		OR	strIO_GHdshk_Riem1_Nachf.b_ExterneBahn
			AND 	bI_NachfRiemHatNurEineSpur )
	AND ( strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnRuecklauf
			OR	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf )
THEN
	fbBahn_Riem2.IwBahnMode.xOhneUeberwachungszeit_AufBahn				:= TRUE;		(* Die maximale Laufzeit einer Platte auf die Bahn wird NICHT überwacht *)
ELSE

	fbBahn_Riem2.IwBahnMode.xOhneUeberwachungszeit_AufBahn				:= FALSE;		(* Die maximale Laufzeit einer Platte auf die Bahn wird überwacht *)
END_IF;

IF ( strIO_GHdshk_Riem2_Nachf.b_ExterneBahn
	AND NOT bI_NachfRiemHatNurEineSpur
	OR	strIO_GHdshk_Riem1_Nachf.b_ExterneBahn
		AND 	bI_NachfRiemHatNurEineSpur )
	AND ( strIO_GHdshk_Riem2.str_JobAktiv_VonBahn = eRolljobVonBahnVorlauf
			OR	strIO_GHdshk_Riem2.str_JobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf )
	OR ( strIO_GHdshk_Riem2_Vorg.b_ExterneBahn
		AND NOT bI_VorgRiemHatNurEineSpur
		OR	strIO_GHdshk_Riem1_Vorg.b_ExterneBahn
			AND 	bI_VorgRiemHatNurEineSpur )
	AND ( strIO_GHdshk_Riem2.str_JobAktiv_VonBahn = eRolljobVonBahnRuecklauf
			OR	strIO_GHdshk_Riem2.str_JobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf )
THEN
	fbBahn_Riem2.IwBahnMode.xOhneUeberwachungszeit_VonBahn				:= TRUE;		(* Die maximale Laufzeit einer Platte von der Bahn wird NICHT überwacht *)
ELSE
	fbBahn_Riem2.IwBahnMode.xOhneUeberwachungszeit_VonBahn				:= FALSE;		(* Die maximale Laufzeit einer Platte von der Bahn wird überwacht *)
END_IF;

fbBahn_Riem2.IwBahnMode.xOhneUeberwachungszeit_AufBahn_AnEndeAnfang			:= FALSE;		(* Laufzeitüberwachung bei Job AufBahn bei 'eRolljobAnsBahnendeVorlauf' oder 'eRolljobAnBahnanfangRuecklauf' *)
fbBahn_Riem2.IwBahnMode.xOhneUeberwachungszeit_VonBahn_AnEndeAnfang			:= FALSE;		(* Laufzeitüberwachung bei Job VonBahn bei 'eRolljobAnsBahnendeVorlauf' oder 'eRolljobAnBahnanfangRuecklauf' *)

fbBahn_Riem2.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitLeer			:= TRUE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' leer gemeldet *)
fbBahn_Riem2.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitWeiter		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' im Ablauf weiter gemacht *)
fbBahn_Riem2.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitNochmal		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' der Ablauf wiederholt *)

fbBahn_Riem2.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitLeer			:= TRUE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' leer gemeldet *)
fbBahn_Riem2.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitWeiter		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' im Ablauf weiter gemacht *)
fbBahn_Riem2.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitNochmal		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' der Ablauf wiederholt *)

(* Modi der Bahn: Positionierungsjobs, z.B. eRolljobAufBahnPosiVorlauf *)
fbBahn_Riem2.IwBahnMode.xAufBahnPosi_AnfangBeachten						:= strIO_GHdshk_Riem2.str_JobAktiv_AufBahn <> eRolljobAufBahnMittigVorlauf	(* Die Positionierung wird erst mit gestartet, wenn Teil in Anfang bzw. Ende bei Rücklauf ist *)
															AND	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn <> eRolljobAufBahnMittigRuecklauf;
fbBahn_Riem2.IwBahnMode.xAufBahnPosi_StopBeiEnde						:= FALSE;		(* Die Positionierung wird abgebrochen, wenn Teil in Ende bzw. Anfang bei Rücklauf ist *)
fbBahn_Riem2.IwBahnMode.xAufBahnPosi_StopBeiEnde_MitFehler					:= FALSE;		(* Fehler ausgeben, wenn Positionierung abgebrochen wird *)

(* Modi der Bahn: Jobs ohne Positionierung, z.B. eRolljobAufBahnVorlauf *)
fbBahn_Riem2.IwBahnMode.xAufBahnVorlauf_StopMitHK						:= TRUE;		(* Beim Job AufBahn im Vorlauf mit HK stehen bleiben und nicht ins Ende durchfahren *)
fbBahn_Riem2.IwBahnMode.xAufBahnVorlauf_NachlaufAmBahnende					:= FALSE;		(* Beim Job AufBahn 'eRolljobAufBahnVorlauf' wird bei Ende eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Riem2.IwBahnMode.xAnsBahnende_MitNachlauf						:= FALSE;		(* Beim Job 'eRolljobAnsBahnendeVorlauf' wird bei Ende eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Riem2.IwBahnMode.xStopMitHK_UeberWeg							:= TRUE;		(* Der Weg Stop mit HK wird über eine Strecke angegeben, sonst Zeit *)
fbBahn_Riem2.IwBahnMode.xNachlaufUebergabe_UeberWeg						:= FALSE;		(* Beim Job VonBahn wird der Nachlauf über einen Weg gemacht, sonst Zeit *)

fbBahn_Riem2.IwBahnMode.xAufBahnRuecklauf_StopMitHK						:= TRUE;		(* Beim Job AufBahn im Rücklauf mit HK stehen bleiben und nicht in Anfang durchfahren *)
fbBahn_Riem2.IwBahnMode.xAufBahnRuecklauf_NachlaufAmBahnanfang				:= FALSE;		(* Beim Job AufBahn 'eRolljobAufBahnRuecklauf' wird bei Anfang eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Riem2.IwBahnMode.xAnBahnanfang_MitNachlauf						:= FALSE;		(* Beim Job 'eRolljobAnBahnanfangRuecklauf' wird bei Anfang eine Nachlaufzeit gestartet -> ausrichten *)

(* Modi der Bahn: Grundstellungsfahrt *)
IF 	strIO_TrE.iAnzahlPlatten > 0												(* es gibt noch Platten auf der Bahn *)
	AND	strIO_TrE.asBarcode[1] <> ''											(* Daten vorhanden *)
	OR	fbBahn_Roll1.IsAnfangBahn											(* Teil im Uebergang *)
		AND	strIO_GHdshk_Roll1_Vorg.b_LiEnde
		AND 	iBahnLetzteBewegung_Sek_2 = 2
	OR	fbBahn_Roll1.IsEndeBahn
		AND	strIO_GHdshk_Roll1_Nachf.b_LiAnfang
		AND 	iBahnLetzteBewegung_Sek_2 = 1
	OR	fbBahn_Riem2.IsAnfangBahn
		AND	strIO_GHdshk_Riem2_Vorg.b_LiEnde
		AND 	iBahnLetzteBewegung_Sek_2 = 12
	OR	fbBahn_Riem2.IsEndeBahn
		AND	strIO_GHdshk_Riem2_Nachf.b_LiAnfang
		AND 	iBahnLetzteBewegung_Sek_2 = 11
THEN
	fbBahn_Riem2.IwBahnMode.iFahrtInGrund							:= eGrund_BelegtMelden;
	fbBahn_Riem2.IwBahnMode.xDatenPruefen_NachGrund						:= FALSE;		(* Nach Fahrt in Grund wird die Hardwarebelegung mit den Daten verglichen *)
ELSE
	fbBahn_Riem2.IwBahnMode.iFahrtInGrund							:= eGrund_FreiMelden;
	fbBahn_Riem2.IwBahnMode.xDatenPruefen_NachGrund						:= TRUE;		(* Nach Fahrt in Grund wird die Hardwarebelegung mit den Daten verglichen *)
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_Bahnmodi_Roll1" Id="{2379256b-2152-4e3f-b162-ff5260b434b9}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*	Anhand der einzelnen Bahnmodi wird dem Transportbaustein 'FB_BahnV2' übergeben, wie er die Teile fahren soll			*)
(*	weitere Erläuterungen zu den einzelnen Bahnmodi sind in 'FB_BahnV2.Up01_Versionen' und der Struktur 'Bahnmode' zu finden	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

(* Angeschlossene Zusatzmodule *)
fbBahn_Roll1.IwBahnMode.xUserInterfaceAktiv							:= TRUE;		(* Bei Laufzeitüberwachung gibt es eine Dialogbox für den Bediener, F_Dialogbox + P_Handling_DialogBox + Struktur 'User_Interface' + 3Tec notwendig *)
(* Modi der Bahn: Überwachungszeit/Laufzeit *)

IF	strIO_GHdshk_Roll1_Vorg.b_ExterneBahn
	AND ( strIO_GHdshk_Roll1.str_JobAktiv_AufBahn = eRolljobAufBahnVorlauf
			OR	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf )
	OR	strIO_GHdshk_Roll1_Nachf.b_ExterneBahn
	AND ( strIO_GHdshk_Roll1.str_JobAktiv_AufBahn = eRolljobAufBahnRuecklauf
			OR	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf )
THEN
	fbBahn_Roll1.IwBahnMode.xOhneUeberwachungszeit_AufBahn				:= TRUE;		(* Die maximale Laufzeit einer Platte auf die Bahn wird NICHT überwacht *)
ELSE

	fbBahn_Roll1.IwBahnMode.xOhneUeberwachungszeit_AufBahn				:= FALSE;		(* Die maximale Laufzeit einer Platte auf die Bahn wird überwacht *)
END_IF;

IF	strIO_GHdshk_Roll1_Nachf.b_ExterneBahn
	AND ( strIO_GHdshk_Roll1.str_JobAktiv_VonBahn = eRolljobVonBahnVorlauf
			OR	strIO_GHdshk_Roll1.str_JobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf )
	OR	strIO_GHdshk_Roll1_Vorg.b_ExterneBahn
	AND ( strIO_GHdshk_Roll1.str_JobAktiv_VonBahn = eRolljobVonBahnRuecklauf
			OR	strIO_GHdshk_Roll1.str_JobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf )
THEN
	fbBahn_Roll1.IwBahnMode.xOhneUeberwachungszeit_VonBahn				:= TRUE;		(* Die maximale Laufzeit einer Platte von der Bahn wird NICHT überwacht *)
ELSE
	fbBahn_Roll1.IwBahnMode.xOhneUeberwachungszeit_VonBahn				:= FALSE;		(* Die maximale Laufzeit einer Platte von der Bahn wird überwacht *)
END_IF;

fbBahn_Roll1.IwBahnMode.xOhneUeberwachungszeit_AufBahn_AnEndeAnfang			:= FALSE;		(* Laufzeitüberwachung bei Job AufBahn bei 'eRolljobAnsBahnendeVorlauf' oder 'eRolljobAnBahnanfangRuecklauf' *)
fbBahn_Roll1.IwBahnMode.xOhneUeberwachungszeit_VonBahn_AnEndeAnfang			:= FALSE;		(* Laufzeitüberwachung bei Job VonBahn bei 'eRolljobAnsBahnendeVorlauf' oder 'eRolljobAnBahnanfangRuecklauf' *)

fbBahn_Roll1.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitLeer			:= TRUE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' leer gemeldet *)
fbBahn_Roll1.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitWeiter		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' im Ablauf weiter gemacht *)
fbBahn_Roll1.IwBahnMode.xError_AufBahnMaxLaufzeit_OhneIni_NachQuitNochmal		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler AufBahn durch 'IsQuittStoerung' der Ablauf wiederholt *)

fbBahn_Roll1.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitLeer			:= TRUE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' leer gemeldet *)
fbBahn_Roll1.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitWeiter		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' im Ablauf weiter gemacht *)
fbBahn_Roll1.IwBahnMode.xError_VonBahnMaxLaufzeit_OhneIni_NachQuitNochmal		:= FALSE;		(* Wenn UserInterfaceAktiv inaktiv, wird Bahn nach Laufzeitfehler VonBahn durch 'IsQuittStoerung' der Ablauf wiederholt *)

(* Modi der Bahn: Positionierungsjobs, z.B. eRolljobAufBahnPosiVorlauf *)
fbBahn_Roll1.IwBahnMode.xAufBahnPosi_AnfangBeachten						:= strIO_GHdshk_Roll1.str_JobAktiv_AufBahn <> eRolljobAufBahnMittigVorlauf	(* Die Positionierung wird erst mit gestartet, wenn Teil in Anfang bzw. Ende bei Rücklauf ist *)
															AND	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn <> eRolljobAufBahnMittigRuecklauf;
fbBahn_Roll1.IwBahnMode.xAufBahnPosi_StopBeiEnde						:= FALSE;		(* Die Positionierung wird abgebrochen, wenn Teil in Ende bzw. Anfang bei Rücklauf ist *)
fbBahn_Roll1.IwBahnMode.xAufBahnPosi_StopBeiEnde_MitFehler					:= FALSE;		(* Fehler ausgeben, wenn Positionierung abgebrochen wird *)

(* Modi der Bahn: Jobs ohne Positionierung, z.B. eRolljobAufBahnVorlauf *)
fbBahn_Roll1.IwBahnMode.xAufBahnVorlauf_StopMitHK						:= TRUE;		(* Beim Job AufBahn im Vorlauf mit HK stehen bleiben und nicht ins Ende durchfahren *)
fbBahn_Roll1.IwBahnMode.xAufBahnVorlauf_NachlaufAmBahnende					:= FALSE;		(* Beim Job AufBahn 'eRolljobAufBahnVorlauf' wird bei Ende eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Roll1.IwBahnMode.xAnsBahnende_MitNachlauf						:= FALSE;		(* Beim Job 'eRolljobAnsBahnendeVorlauf' wird bei Ende eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Roll1.IwBahnMode.xStopMitHK_UeberWeg							:= TRUE;		(* Der Weg Stop mit HK wird über eine Strecke angegeben, sonst Zeit *)
fbBahn_Roll1.IwBahnMode.xNachlaufUebergabe_UeberWeg						:= FALSE;		(* Beim Job VonBahn wird der Nachlauf über einen Weg gemacht, sonst Zeit *)

fbBahn_Roll1.IwBahnMode.xAufBahnRuecklauf_StopMitHK						:= TRUE;		(* Beim Job AufBahn im Rücklauf mit HK stehen bleiben und nicht in Anfang durchfahren *)
fbBahn_Roll1.IwBahnMode.xAufBahnRuecklauf_NachlaufAmBahnanfang				:= FALSE;		(* Beim Job AufBahn 'eRolljobAufBahnRuecklauf' wird bei Anfang eine Nachlaufzeit gestartet -> ausrichten *)
fbBahn_Roll1.IwBahnMode.xAnBahnanfang_MitNachlauf						:= FALSE;		(* Beim Job 'eRolljobAnBahnanfangRuecklauf' wird bei Anfang eine Nachlaufzeit gestartet -> ausrichten *)

(* Modi der Bahn: Grundstellungsfahrt *)
IF 	strIO_TrE.iAnzahlPlatten > 0												(* es gibt noch Platten auf der Bahn *)
	AND	strIO_TrE.asBarcode[1] <> ''											(* Daten vorhanden *)
	OR	fbBahn_Roll1.IsAnfangBahn											(* Teil im Uebergang *)
		AND	strIO_GHdshk_Roll1_Vorg.b_LiEnde
		AND ( iBahnLetzteBewegung_Sek_1 = 2
			OR	iBahnLetzteBewegung_Sek_2 = 2 )
	OR	fbBahn_Roll1.IsEndeBahn
		AND	strIO_GHdshk_Roll1_Nachf.b_LiAnfang
		AND ( iBahnLetzteBewegung_Sek_1 = 1
			OR	iBahnLetzteBewegung_Sek_2 = 1 )
	OR	fbBahn_Riem1.IsAnfangBahn
		AND	strIO_GHdshk_Riem1_Vorg.b_LiEnde
		AND 	iBahnLetzteBewegung_Sek_1 = 12
	OR	fbBahn_Riem1.IsEndeBahn
		AND	strIO_GHdshk_Riem1_Nachf.b_LiAnfang
		AND 	iBahnLetzteBewegung_Sek_1 = 11
	OR	fbBahn_Riem2.IsAnfangBahn
		AND	strIO_GHdshk_Riem2_Vorg.b_LiEnde
		AND 	iBahnLetzteBewegung_Sek_2 = 12
	OR	fbBahn_Riem2.IsEndeBahn
		AND	strIO_GHdshk_Riem2_Nachf.b_LiAnfang
		AND 	iBahnLetzteBewegung_Sek_2 = 11
THEN
	fbBahn_Roll1.IwBahnMode.iFahrtInGrund							:= eGrund_BelegtMelden;
	fbBahn_Roll1.IwBahnMode.xDatenPruefen_NachGrund						:= FALSE;		(* Nach Fahrt in Grund wird die Hardwarebelegung mit den Daten verglichen *)
ELSE
	fbBahn_Roll1.IwBahnMode.iFahrtInGrund							:= eGrund_FreiMelden;
	fbBahn_Roll1.IwBahnMode.xDatenPruefen_NachGrund						:= TRUE;		(* Nach Fahrt in Grund wird die Hardwarebelegung mit den Daten verglichen *)
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="B_Zeiten_Rampen_Speed_Riem1" Id="{68765d1f-874c-486b-b3bb-de155e95d036}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Die Zeiten, Rampen und die Geschwindigkeit der Bahn wird anhand von Jobs und Teileposition dynamisch geändert	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

fbBahn_Riem1.IwBahnSpeed	:= strIO_GHdshk_Riem1.str_BahnSpeed;
fbBahn_Riem1.IwBahnZeiten	:= strIO_GHdshk_Riem1.str_BahnZeiten;

(* Bei Grundstellungsfahrt ohne Daten schnell fahren. *)
IF	fbBahn_Riem1.xFahrtInGrund
	AND	strIO_TrE.iAnzahlPlatten = 0
	AND 	bI_BahnenGrundSchnell_Sek_1
THEN
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK;
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK;
END_IF;

(* Damit die unterschiedlichen Bahnlängen beachtet werden. *)
fbBahn_Riem1.IwBahnZeiten.tMaxLaufzeit_Grund:= F_Laufzeit_Bahn( fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni, strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge ) + t#3s;
fbBahn_Riem1.IwBahnZeiten.tMaxLaufzeit_Ueberwachung:= F_Laufzeit_Bahn( fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni, strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge ) + t#5s;

(* Damit wenn ein VonBahnJob ansteht nicht erst am schleich Sensor gebremst wird sondern dann mit VonBahn Speed durchgestartet wird. *)
IF	( fbBahn_Riem1.IwDoJob_VonBahn = eRolljobVonBahnVorlauf
		OR	 fbBahn_Riem1.IwDoJob_VonBahn = eRolljobVonBahnPosiVorlauf )
	AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobAnsBahnEndeVorlauf
THEN
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn;
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn;

ELSIF	( fbBahn_Riem1.IwDoJob_VonBahn = eRolljobVonBahnRuecklauf
		OR	 fbBahn_Riem1.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf )
	AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobAnBahnanfangRuecklauf
THEN
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn;
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn;
END_IF;

(* Damit wenn kein VonBahnJob ansteht immer ins Ende oder Anfang geschlichen wird. *)
IF	fbBahn_Riem1.IsBelegtVorEndeBahn
	AND (	fbBahn_Riem1.IwDoJob_VonBahn <> eRolljobVonBahnVorlauf
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
		AND	fbBahn_Riem1.IwDoJob_VonBahn <> eRolljobVonBahnPosiVorlauf
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
		OR NOT strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
		OR NOT strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe )
THEN
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;

ELSIF	fbBahn_Riem1.IsBelegtVorAnfangBahn
	AND (	fbBahn_Riem1.IwDoJob_VonBahn <> eRolljobVonBahnRuecklauf
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
		AND	fbBahn_Riem1.IwDoJob_VonBahn <> eRolljobVonBahnPosiRuecklauf
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
		OR NOT strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion
		OR NOT strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe )
THEN
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn:= fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
END_IF;

(* Damit bei VonBahn der Speed der ZielSektion übernommen wird. *)
IF	(( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
		AND ( fbBahn_Riem1.OwAblaufStatus_VonBahn >= 312
			AND	fbBahn_Riem1.OwAblaufStatus_VonBahn <= 319
			OR	fbBahn_Riem1.OwAblaufStatus_VonBahn = 310
				AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
					>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
						- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
						- strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )))
		OR ( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
			AND ( fbBahn_Riem1.OwAblaufStatus_VonBahn >= 754
				AND	fbBahn_Riem1.OwAblaufStatus_VonBahn <= 759
				OR 	fbBahn_Riem1.OwAblaufStatus_VonBahn = 752
					AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
						>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
							- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
							- strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang ))))
	AND ( fbBahn_Riem1.IsEndeBahn
		OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
		OR	fbGeberHandling_VonBahn_Riem1.OwPosiRestWert > strIO_GHdshk_Riem1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn )
	AND 	strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
	AND 	strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
	AND NOT bI_OhneSynchronVonBahn_Riem1
THEN
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Riem1_Nachf.lr_Bahnspeed_Vorgabe);

ELSIF	(( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
		AND ( fbBahn_Riem1.OwAblaufStatus_VonBahn >= 352
			AND	fbBahn_Riem1.OwAblaufStatus_VonBahn <= 359
			OR	fbBahn_Riem1.OwAblaufStatus_VonBahn = 350
				AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
					>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
						- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
						- strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )))
		OR ( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
			AND ( fbBahn_Riem1.OwAblaufStatus_VonBahn >= 754
				AND	fbBahn_Riem1.OwAblaufStatus_VonBahn <= 759
				OR 	fbBahn_Riem1.OwAblaufStatus_VonBahn = 752
					AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
						>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
							- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
							- strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang ))))
	AND ( fbBahn_Riem1.IsAnfangBahn
		OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
		OR	fbGeberHandling_VonBahn_Riem1.OwPosiRestWert > strIO_GHdshk_Riem1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn )
	AND 	strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion
	AND 	strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
	AND NOT bI_OhneSynchronVonBahn_Riem1
THEN
	fbBahn_Riem1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Riem1_Vorg.lr_Bahnspeed_Vorgabe);
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="B_Zeiten_Rampen_Speed_Riem2" Id="{296ba5ac-8fab-4b7f-bcbd-52b1ea0576f6}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Die Zeiten, Rampen und die Geschwindigkeit der Bahn wird anhand von Jobs und Teileposition dynamisch geändert	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

fbBahn_Riem2.IwBahnSpeed	:= strIO_GHdshk_Riem2.str_BahnSpeed;
fbBahn_Riem2.IwBahnZeiten	:= strIO_GHdshk_Riem2.str_BahnZeiten;

(* Bei Grundstellungsfahrt ohne Daten schnell fahren. *)
IF	fbBahn_Riem2.xFahrtInGrund
	AND	strIO_TrE.iAnzahlPlatten = 0
	AND 	bI_BahnenGrundSchnell_Sek_2
THEN
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK;
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK;
END_IF;

(* Damit die unterschiedlichen Bahnlängen beachtet werden. *)
fbBahn_Riem2.IwBahnZeiten.tMaxLaufzeit_Grund:= F_Laufzeit_Bahn( fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni, strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge ) + t#3s;
fbBahn_Riem2.IwBahnZeiten.tMaxLaufzeit_Ueberwachung:= F_Laufzeit_Bahn( fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni, strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge ) + t#5s;

(* Damit wenn ein VonBahnJob ansteht nicht erst am schleich Sensor gebremst wird sondern dann mit VonBahn Speed durchgestartet wird. *)
IF	( fbBahn_Riem2.IwDoJob_VonBahn = eRolljobVonBahnVorlauf
		OR	 fbBahn_Riem2.IwDoJob_VonBahn = eRolljobVonBahnPosiVorlauf )
	AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobAnsBahnEndeVorlauf
THEN
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_VonBahn;
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_VonBahn;

ELSIF	( fbBahn_Riem2.IwDoJob_VonBahn = eRolljobVonBahnRuecklauf
		OR	 fbBahn_Riem2.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf )
	AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobAnBahnanfangRuecklauf
THEN
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn;
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn;
END_IF;

(* Damit wenn kein VonBahnJob ansteht immer ins Ende oder Anfang geschlichen wird. *)
IF	fbBahn_Riem2.IsBelegtVorEndeBahn
	AND (	fbBahn_Riem2.IwDoJob_VonBahn <> eRolljobVonBahnVorlauf
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
		AND	fbBahn_Riem2.IwDoJob_VonBahn <> eRolljobVonBahnPosiVorlauf
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
		OR NOT strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
			AND	bI_NachfRiemHatNurEineSpur
		OR NOT strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
			AND	bI_NachfRiemHatNurEineSpur
		OR NOT strIO_GHdshk_Riem2_Nachf.b_FreimeldungAnVorSektion
			AND NOT strIO_GHdshk_Riem2_Nachf.b_SektionenKoppelnInX
			AND NOT bI_NachfRiemHatNurEineSpur
		OR NOT strIO_GHdshk_Riem2_Nachf.b_BahnIstAufFoerderhoehe
			AND NOT strIO_GHdshk_Riem2_Nachf.b_SektionenKoppelnInX
			AND NOT bI_NachfRiemHatNurEineSpur )
THEN
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;

ELSIF	fbBahn_Riem2.IsBelegtVorAnfangBahn
	AND (	fbBahn_Riem2.IwDoJob_VonBahn <> eRolljobVonBahnRuecklauf
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
		AND	fbBahn_Riem2.IwDoJob_VonBahn <> eRolljobVonBahnPosiRuecklauf
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
		OR NOT strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion
			AND	bI_VorgRiemHatNurEineSpur
		OR NOT strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
			AND	bI_VorgRiemHatNurEineSpur
		OR NOT strIO_GHdshk_Riem2_Vorg.b_FreimeldungAnNachSektion
			AND NOT strIO_GHdshk_Riem2_Vorg.b_SektionenKoppelnInX
			AND NOT bI_VorgRiemHatNurEineSpur
		OR NOT strIO_GHdshk_Riem2_Vorg.b_BahnIstAufFoerderhoehe
			AND NOT strIO_GHdshk_Riem2_Vorg.b_SektionenKoppelnInX
			AND NOT bI_VorgRiemHatNurEineSpur )
THEN
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
	fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn:= fbBahn_Riem2.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
END_IF;

(* Damit bei VonBahn der Speed der ZielSektion übernommen wird. *)
IF	(( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
		AND ( fbBahn_Riem2.OwAblaufStatus_VonBahn >= 312
			AND	fbBahn_Riem2.OwAblaufStatus_VonBahn <= 319
			OR	fbBahn_Riem2.OwAblaufStatus_VonBahn = 310
				AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
					>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
						- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiEnde_EndeBahn
						- strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )))
		OR ( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
			AND ( fbBahn_Riem2.OwAblaufStatus_VonBahn >= 754
				AND	fbBahn_Riem2.OwAblaufStatus_VonBahn <= 759
				OR 	fbBahn_Riem2.OwAblaufStatus_VonBahn = 752
					AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
						>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
							- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiEnde_EndeBahn
							- strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang ))))
	AND ( fbBahn_Riem2.IsEndeBahn
		OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
		OR	fbGeberHandling_VonBahn_Riem2.OwPosiRestWert > strIO_GHdshk_Riem2.str_Bahndaten.rFreigabeFahrenRestwegVonBahn )
	AND 	( strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
		AND 	strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
		AND	bI_NachfRiemHatNurEineSpur
		OR	strIO_GHdshk_Riem2_Nachf.b_FreimeldungAnVorSektion
			AND 	strIO_GHdshk_Riem2_Nachf.b_BahnIstAufFoerderhoehe
			AND NOT bI_NachfRiemHatNurEineSpur )
	AND NOT bI_OhneSynchronVonBahn_Riem2
THEN
	IF	bI_NachfRiemHatNurEineSpur
	THEN
		fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Riem1_Nachf.lr_Bahnspeed_Vorgabe);
	ELSE
		fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Riem2_Nachf.lr_Bahnspeed_Vorgabe);
	END_IF;

ELSIF	(( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
		AND ( fbBahn_Riem2.OwAblaufStatus_VonBahn >= 352
			AND	fbBahn_Riem2.OwAblaufStatus_VonBahn <= 359
			OR	fbBahn_Riem2.OwAblaufStatus_VonBahn = 350
				AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
					>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
						- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
						- strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )))
		OR ( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
			AND ( fbBahn_Riem2.OwAblaufStatus_VonBahn >= 754
				AND	fbBahn_Riem2.OwAblaufStatus_VonBahn <= 759
				OR 	fbBahn_Riem2.OwAblaufStatus_VonBahn = 752
					AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
						>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
							- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
							- strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang ))))
	AND ( fbBahn_Riem2.IsAnfangBahn
		OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
		OR	fbGeberHandling_VonBahn_Riem2.OwPosiRestWert > strIO_GHdshk_Riem2.str_Bahndaten.rFreigabeFahrenRestwegVonBahn )
	AND ( strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion
			AND 	strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
			AND	bI_VorgRiemHatNurEineSpur
		OR	strIO_GHdshk_Riem2_Vorg.b_FreimeldungAnNachSektion
			AND 	strIO_GHdshk_Riem2_Vorg.b_BahnIstAufFoerderhoehe
			AND NOT bI_VorgRiemHatNurEineSpur )
	AND NOT bI_OhneSynchronVonBahn_Riem2
THEN
	IF	bI_VorgRiemHatNurEineSpur
	THEN
		fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Riem1_Vorg.lr_Bahnspeed_Vorgabe);
	ELSE
		fbBahn_Riem2.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Riem2_Vorg.lr_Bahnspeed_Vorgabe);
	END_IF;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="B_Zeiten_Rampen_Speed_Roll1" Id="{6b686fdb-f809-4974-9d48-5fb95f183e63}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Die Zeiten, Rampen und die Geschwindigkeit der Bahn wird anhand von Jobs und Teileposition dynamisch geändert	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

fbBahn_Roll1.IwBahnSpeed	:= strIO_GHdshk_Roll1.str_BahnSpeed;
fbBahn_Roll1.IwBahnZeiten	:= strIO_GHdshk_Roll1.str_BahnZeiten;

(* Bei Grundstellungsfahrt ohne Daten schnell fahren. *)
IF	fbBahn_Roll1.xFahrtInGrund
	AND	strIO_TrE.iAnzahlPlatten = 0
	AND 	bI_BahnenGrundSchnell_Sek_1
	AND	bI_BahnenGrundSchnell_Sek_2
THEN
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK;
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK;
END_IF;

(* Damit die unterschiedlichen Bahnlängen beachtet werden. *)
fbBahn_Roll1.IwBahnZeiten.tMaxLaufzeit_Grund:= F_Laufzeit_Bahn( fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni, strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge ) + t#3s;
fbBahn_Roll1.IwBahnZeiten.tMaxLaufzeit_Ueberwachung:= F_Laufzeit_Bahn( fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni, strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge ) + t#5s;

(* Damit wenn ein VonBahnJob ansteht nicht erst am schleich Sensor gebremst wird sondern dann mit VonBahn Speed durchgestartet wird. *)
IF	( fbBahn_Roll1.IwDoJob_VonBahn = eRolljobVonBahnVorlauf
		OR	 fbBahn_Roll1.IwDoJob_VonBahn = eRolljobVonBahnPosiVorlauf )
	AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobAnsBahnEndeVorlauf
THEN
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn;
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn;

ELSIF	( fbBahn_Roll1.IwDoJob_VonBahn = eRolljobVonBahnRuecklauf
		OR	 fbBahn_Roll1.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf )
	AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobAnBahnanfangRuecklauf
THEN
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn;
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn;
END_IF;

(* Damit wenn kein VonBahnJob ansteht immer ins Ende oder Anfang geschlichen wird. *)
IF	fbBahn_Roll1.IsBelegtVorEndeBahn
	AND (	fbBahn_Roll1.IwDoJob_VonBahn <> eRolljobVonBahnVorlauf
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
		AND	fbBahn_Roll1.IwDoJob_VonBahn <> eRolljobVonBahnPosiVorlauf
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
		OR NOT strIO_GHdshk_Roll1_Nachf.b_FreimeldungAnVorSektion
		OR NOT strIO_GHdshk_Roll1_Nachf.b_BahnIstAufFoerderhoehe )
THEN
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_HK:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_AufBahn_SlowIni;

ELSIF	fbBahn_Roll1.IsBelegtVorAnfangBahn
	AND (	fbBahn_Roll1.IwDoJob_VonBahn <> eRolljobVonBahnRuecklauf
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
		AND	fbBahn_Roll1.IwDoJob_VonBahn <> eRolljobVonBahnPosiRuecklauf
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
		OR NOT strIO_GHdshk_Roll1_Vorg.b_FreimeldungAnNachSektion
		OR NOT strIO_GHdshk_Roll1_Vorg.b_BahnIstAufFoerderhoehe )
THEN
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_HK:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn:= fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_AufBahn_SlowIni;
END_IF;

(* Damit bei VonBahn der Speed der ZielSektion übernommen wird. *)
IF	(( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
		AND ( fbBahn_Roll1.OwAblaufStatus_VonBahn >= 312
			AND	fbBahn_Roll1.OwAblaufStatus_VonBahn <= 319
			OR	fbBahn_Roll1.OwAblaufStatus_VonBahn = 310
				AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
					>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
						- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
						- strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )))
		OR ( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
			AND ( fbBahn_Roll1.OwAblaufStatus_VonBahn >= 754
				AND	fbBahn_Roll1.OwAblaufStatus_VonBahn <= 759
				OR 	fbBahn_Roll1.OwAblaufStatus_VonBahn = 752
					AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
						>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
							- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
							- strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang ))))
	AND ( fbBahn_Roll1.IsEndeBahn
		OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
		OR	fbGeberHandling_VonBahn_Roll1.OwPosiRestWert > strIO_GHdshk_Roll1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn )
	AND  	strIO_GHdshk_Roll1_Nachf.b_FreimeldungAnVorSektion
	AND 	strIO_GHdshk_Roll1_Nachf.b_BahnIstAufFoerderhoehe
	AND NOT bI_OhneSynchronVonBahn_Roll1
THEN
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Vorlauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Roll1_Nachf.lr_Bahnspeed_Vorgabe);

ELSIF	(( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
		AND ( fbBahn_Roll1.OwAblaufStatus_VonBahn >= 352
			AND	fbBahn_Roll1.OwAblaufStatus_VonBahn <= 359
			OR	fbBahn_Roll1.OwAblaufStatus_VonBahn = 350
				AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
					>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
						- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
						- strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )))
		OR ( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
			AND ( fbBahn_Roll1.OwAblaufStatus_VonBahn >= 754
				AND	fbBahn_Roll1.OwAblaufStatus_VonBahn <= 759
				OR 	fbBahn_Roll1.OwAblaufStatus_VonBahn = 752
					AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
						>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
							- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
							- strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang ))))
	AND ( fbBahn_Roll1.IsAnfangBahn
		OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
		OR	fbGeberHandling_VonBahn_Roll1.OwPosiRestWert > strIO_GHdshk_Roll1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn )
	AND  	strIO_GHdshk_Roll1_Vorg.b_FreimeldungAnNachSektion
	AND 	strIO_GHdshk_Roll1_Vorg.b_BahnIstAufFoerderhoehe
	AND NOT bI_OhneSynchronVonBahn_Roll1
THEN
	fbBahn_Roll1.IwBahnSpeed.iSpeed_Ruecklauf_VonBahn:= LREAL_TO_INT(strIO_GHdshk_Roll1_Vorg.lr_Bahnspeed_Vorgabe);
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="C_Eingaenge_Riem1" Id="{401a30e8-e0a7-420f-948e-0f587b8f4262}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Eingänge																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
IF	bI_Testbetrieb
THEN
	strIO_GHdshk_Riem1.str_Bahndaten.rWegStopVorBahnAnfang:= 0;
	strIO_GHdshk_Riem1.str_Bahndaten.rWegStopVorBahnEnde:= 0;
END_IF;

bSwAnfang_Riem1:=
	( strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
		>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
			- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
			- strIO_GHdshk_Riem1.str_Bahndaten.rWegStopVorBahnAnfang ))
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
	AND 	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem1.str_DoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem1.str_Bahndaten.rWegStopVorBahnAnfang > 0
	AND 	strIO_TrE.iAnzahlPlatten > 0
	AND 	iBahnLetzteBewegung_Sek_1 = 12;

bSwEnde_Riem1:=
	( strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
		>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
			- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
			- strIO_GHdshk_Riem1.str_Bahndaten.rWegStopVorBahnEnde ))
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
	AND 	fbBahn_Riem1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
	AND 	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem1.str_DoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem1.str_Bahndaten.rWegStopVorBahnEnde > 0
	AND 	strIO_TrE.iAnzahlPlatten > 0
	AND 	iBahnLetzteBewegung_Sek_1 = 11;

bSwVorAnfang_Riem1:=
	( fbBahn_Riem1.xFahrtInGrund										(* Slow Speed bei Fahrt in Grund und ans Bahnende *)
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAnBahnanfangRuecklauf
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Riem1.OwJobAktiv_VonBahn  = eRolljobAnBahnanfangRuecklauf
		AND	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnMittigRuecklauf
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnRuecklauf
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1] > 0
		AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
			>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
				- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
				- strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )
		AND ( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob
				OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobAnBahnanfangRuecklauf
				OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
					AND ( NOT strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion )
				OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
					AND ( NOT strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion ))
		AND NOT bI_Testbetrieb ))
	AND NOT strIO_GHdshk_Riem1.b_BahnSteht;

bSwVorEnde_Riem1:=
	( fbBahn_Riem1.xFahrtInGrund										(* Slow Speed bei Fahrt in Grund und ans Bahnende *)
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAnsBahnendeVorlauf
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobAnsBahnendeVorlauf
		AND	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1] = 0 ) 
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnMittigVorlauf
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnVorlauf
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1] > 0
		AND	strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1]
			>	( strIO_GHdshk_Riem1.str_Bahndaten.rGesamtLaenge
				- strIO_GHdshk_Riem1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
				- strIO_GHdshk_Riem1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )
		AND ( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob
				OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobAnsBahnendeVorlauf
				OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
					AND ( NOT strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion )
				OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
					AND ( NOT strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion ))
		AND NOT bI_Testbetrieb ))
	AND NOT strIO_GHdshk_Riem1.b_BahnSteht;

(* Eingänge: Hand / Automatik *)
fbBahn_Riem1.IwBahnName:= strIO_GHdshk_Riem1.s_Name;

fbBahn_Riem1.IsHand:= bI_Hand;

fbBahn_Riem1.IsAutomatik:= bI_Automatik;

fbBahn_Riem1.IsFreigabe_Automatik:= ( bI_AufFoerderhoehe_Riem1
							OR	fbBahn_Riem1.OsBahnAufFoerderhoehe
								AND	bI_Testbetrieb )
						AND ( NOT strIO_GHdshk_Riem2.b_SektionenKoppelnInY
							OR	bI_AufFoerderhoehe_Riem2
							OR	fbBahn_Riem1.OsBahnAufFoerderhoehe
								AND	bI_Testbetrieb )
						AND	bI_FreigabeAutomatik
						OR	fbBahn_Riem1.xFahrtInGrund
						OR	fbBahn_Riem1.SKet1 = 50
						OR	fbBahn_Riem1.OwBahnStatus = iAutomatikBereitJob;

fbBahn_Riem1.IsDauerlauf_Aktivieren:=
	( bI_FreigabeHandVorZurueck_Riem1
		OR	bI_FreigabeHandHebenSenkenSek1 )
	AND	gxDauerlauf_Aktiv;

fbBahn_Riem1.IsHand_Takt:= gTakt44;

fbBahn_Riem1.IsTHandVor:=
	bI_FreigabeHandVorZurueck_Riem1
	AND ( bI_AufFoerderhoehe_Riem1
		OR	fbBahn_Riem1.OsBahnAufFoerderhoehe
			AND	bI_Testbetrieb )
	AND ( strIO_GLmHand.bI_Vor
			AND NOT bI_VorZurueckInversHand
		OR	strIO_GLmHand.bI_Zurueck
			AND	bI_VorZurueckInversHand );

fbBahn_Riem1.IsTHandZurueck:=
	bI_FreigabeHandVorZurueck_Riem1
	AND	bI_BahnDarfZurueckHand_Riem1
	AND ( bI_AufFoerderhoehe_Riem1
			OR	fbBahn_Riem1.OsBahnAufFoerderhoehe
				AND	bI_Testbetrieb )
	AND ( strIO_GLmHand.bI_Zurueck
			AND NOT bI_VorZurueckInversHand
		OR	strIO_GLmHand.bI_Vor
			AND	bI_VorZurueckInversHand );

fbBahn_Riem1.IsTHandHeben:= FALSE;

fbBahn_Riem1.IsTHandSenken:= FALSE;



(* Eingänge: Sicherheit / Störung / Quittierung *)
fbBahn_Riem1.IsReset:=
	bI_FreigabeReset
	AND	strIO_GLmHand.bI_Reset;

fbBahn_Riem1.IsQuittStoerung:=
	strIO_GLmHand.bI_QuittStoerung;

fbBahn_Riem1.IsStoerungAntrieb:=
	( bI_StoerungAntrieb_Riem1
	OR	fbRampe_Riem1.bQ_Error )
	AND NOT bI_Testbetrieb;

fbBahn_Riem1.IsSicherheitOK:=
	bI_SicherheitOK
	OR 	bI_Testbetrieb;



(* Eingänge: Hardware *)
fbBahn_Riem1.IsAnfangBahn:=
	fbEntprellenAnfang_Riem1.OsSensor
	OR	bSwAnfang_Riem1
	OR	fbEntprellenAnfang_Riem2.OsSensor
		AND	strIO_GHdshk_Riem2.b_SektionenKoppelnInY;

fbBahn_Riem1.IsEndeBahn:=
	fbEntprellenEnde_Riem1.OsSensor
	OR	bSwEnde_Riem1
	OR	fbEntprellenEnde_Riem2.OsSensor
		AND	strIO_GHdshk_Riem2.b_SektionenKoppelnInY;

fbBahn_Riem1.IsBelegtVorAnfangBahn:=
	fbEntprellenVorAnfang_Riem1.OsSensor
	OR	bSwVorAnfang_Riem1;

fbBahn_Riem1.IsBelegtVorEndeBahn:=
	fbEntprellenVorEnde_Riem1.OsSensor
	OR	bSwVorEnde_Riem1;

fbBahn_Riem1.IsMitteBahn:=
	strIO_TrE.iAnzahlPlatten > 0						(* es gibt noch Platten auf der Bahn *)
	AND	strIO_TrE.asBarcode[1] <> '';					(* Daten vorhanden *)

fbBahn_Riem1.IsBahnIstAufFoerderhoehe	:= ( bI_AufFoerderhoehe_Riem1
								OR	fbBahn_Riem1.OsBahnAufFoerderhoehe
									AND	bI_Testbetrieb )
								AND ( NOT strIO_GHdshk_Riem2.b_SektionenKoppelnInY
									OR	bI_AufFoerderhoehe_Riem2
									OR	fbBahn_Riem2.OsBahnAufFoerderhoehe
										AND	bI_Testbetrieb );
fbBahn_Riem1.IsTestbetrieb			:= bI_Testbetrieb;
fbBahn_Riem1.IsFreigabe_FahrtInGrund	:= TRUE;

fbBahn_Riem1.IsFreimeldungVonVorsektion:=
	( strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion
		AND	strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe )
	OR ( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
		AND	fbGeberHandling_VonBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_VonBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn
		AND NOT fbBahn_Riem1.IsAnfangBahn );

fbBahn_Riem1.IsFreimeldungVonNachsektion:=
	( strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
		AND	strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe )
	OR ( fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
		AND	fbGeberHandling_VonBahn_Riem1.OwPosiRestWert > 0
		AND	fbGeberHandling_VonBahn_Riem1.OwPosiRestWert < strIO_GHdshk_Riem1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn
		AND NOT fbBahn_Riem1.IsEndeBahn );


(* Eingänge: Zusatzmodule *)
fbBahn_Riem1.IsPosi_Aktiv_AufBahn:= fbGeberHandling_AufBahn_Riem1.OsAktiv;
fbBahn_Riem1.IsPosi_Fertig_AufBahn:= fbGeberHandling_AufBahn_Riem1.OsFertig
							OR	bI_AbbruchPosi_AufBahn_Riem1
								AND ( fbBahn_Riem1.SKet1 = 104
									OR	fbBahn_Riem1.SKet1 = 144
									OR	fbBahn_Riem1.SKet1 = 152
									OR	fbBahn_Riem1.SKet1 = 704
									OR	fbBahn_Riem1.SKet1 = 826
									OR	fbBahn_Riem1.SKet1 = 920 );

fbBahn_Riem1.IsPosi_Aktiv_VonBahn:= fbGeberHandling_VonBahn_Riem1.OsAktiv;
fbBahn_Riem1.IsPosi_Fertig_VonBahn:= fbGeberHandling_VonBahn_Riem1.OsFertig
							OR	bI_AbbruchPosi_VonBahn_Riem1
								AND ( fbBahn_Riem1.SKet2 = 314
									OR	fbBahn_Riem1.SKet2 = 354
									OR	fbBahn_Riem1.SKet2 = 754
									OR	fbBahn_Riem1.SKet2 = 759 );

fbBahn_Riem1.IsLaderHatPlatteGeholt		:= strIO_GHdshk_Riem1.b_HatPlatteGeholt;
fbBahn_Riem1.IsLaderHatPlatteAbgelegt	:= strIO_GHdshk_Riem1.b_HatPlatteAbgelegt;]]></ST>
      </Implementation>
    </Action>
    <Action Name="C_Eingaenge_Riem2" Id="{5180db05-ba1c-4794-83d1-e0e347ef8621}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Eingänge																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
IF	bI_Testbetrieb
THEN
	strIO_GHdshk_Riem2.str_Bahndaten.rWegStopVorBahnAnfang:= 0;
	strIO_GHdshk_Riem2.str_Bahndaten.rWegStopVorBahnEnde:= 0;
END_IF;

bSwAnfang_Riem2:=
	( strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
		>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
			- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
			- strIO_GHdshk_Riem2.str_Bahndaten.rWegStopVorBahnAnfang ))
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
	AND 	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem2.str_DoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem2.str_Bahndaten.rWegStopVorBahnAnfang > 0
	AND 	strIO_TrE.iAnzahlPlatten > 0
	AND 	iBahnLetzteBewegung_Sek_2 = 12;

bSwEnde_Riem2:=
	( strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
		>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
			- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiEnde_EndeBahn
			- strIO_GHdshk_Riem2.str_Bahndaten.rWegStopVorBahnEnde ))
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
	AND 	fbBahn_Riem2.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
	AND 	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem2.str_DoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Riem2.str_Bahndaten.rWegStopVorBahnEnde > 0
	AND 	strIO_TrE.iAnzahlPlatten > 0
	AND 	iBahnLetzteBewegung_Sek_2 = 11;

bSwVorAnfang_Riem2:=
	( fbBahn_Riem2.xFahrtInGrund										(* Slow Speed bei Fahrt in Grund und ans Bahnende *)
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAnBahnanfangRuecklauf
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Riem2.OwJobAktiv_VonBahn  = eRolljobAnBahnanfangRuecklauf
		AND	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnMittigRuecklauf
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnRuecklauf
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1] > 0
		AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
			>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
				- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
				- strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )
		AND ( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob
				OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobAnBahnanfangRuecklauf
				OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
					AND ( NOT strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
							AND	bI_VorgRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnVorSektion
							AND	bI_VorgRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Vorg.b_BahnIstAufFoerderhoehe
							AND NOT bI_VorgRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Vorg.b_FreimeldungAnVorSektion
							AND NOT bI_VorgRiemHatNurEineSpur )
				OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
					AND ( NOT strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
							AND	bI_VorgRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnVorSektion
							AND	bI_VorgRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Vorg.b_BahnIstAufFoerderhoehe
							AND NOT bI_VorgRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Vorg.b_FreimeldungAnVorSektion
							AND NOT bI_VorgRiemHatNurEineSpur ))
		AND NOT bI_Testbetrieb ))
	AND NOT strIO_GHdshk_Riem2.b_BahnSteht;

bSwVorEnde_Riem2:=
	( fbBahn_Riem2.xFahrtInGrund										(* Slow Speed bei Fahrt in Grund und ans Bahnende *)
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAnsBahnendeVorlauf
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobAnsBahnendeVorlauf
		AND	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnMittigVorlauf
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnVorlauf
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1] > 0
		AND	strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1]
			>	( strIO_GHdshk_Riem2.str_Bahndaten.rGesamtLaenge
				- strIO_GHdshk_Riem2.str_Bahndaten.rAbstand_LiEnde_EndeBahn
				- strIO_GHdshk_Riem2.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )
		AND ( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob
				OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobAnsBahnendeVorlauf
				OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
					AND ( NOT strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
							AND	bI_NachfRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
							AND	bI_NachfRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Nachf.b_BahnIstAufFoerderhoehe
							AND NOT bI_NachfRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Nachf.b_FreimeldungAnVorSektion
							AND NOT bI_NachfRiemHatNurEineSpur )
				OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
					AND ( NOT strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
							AND	bI_NachfRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
							AND	bI_NachfRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Nachf.b_BahnIstAufFoerderhoehe
							AND NOT bI_NachfRiemHatNurEineSpur
						OR NOT strIO_GHdshk_Riem2_Nachf.b_FreimeldungAnVorSektion
							AND NOT bI_NachfRiemHatNurEineSpur ))
		AND NOT bI_Testbetrieb ))
	AND NOT strIO_GHdshk_Riem2.b_BahnSteht;

(* Eingänge: Hand / Automatik *)
fbBahn_Riem2.IwBahnName:= strIO_GHdshk_Riem2.s_Name;

fbBahn_Riem2.IsHand:= bI_Hand;

fbBahn_Riem2.IsAutomatik:= bI_Automatik;

fbBahn_Riem2.IsFreigabe_Automatik:= ( bI_AufFoerderhoehe_Riem2
							OR	fbBahn_Riem2.OsBahnAufFoerderhoehe
								AND	bI_Testbetrieb )
						AND ( NOT strIO_GHdshk_Riem1.b_SektionenKoppelnInY
							OR	bI_AufFoerderhoehe_Riem1
							OR	fbBahn_Riem2.OsBahnAufFoerderhoehe
								AND	bI_Testbetrieb )
						AND	bI_FreigabeAutomatik
						OR	fbBahn_Riem2.xFahrtInGrund
						OR	fbBahn_Riem2.SKet1 = 50
						OR	fbBahn_Riem2.OwBahnStatus = iAutomatikBereitJob;

fbBahn_Riem2.IsDauerlauf_Aktivieren:=
	( bI_FreigabeHandVorZurueck_Riem2
		OR	bI_FreigabeHandHebenSenkenSek2 )
	AND	gxDauerlauf_Aktiv;

fbBahn_Riem2.IsHand_Takt:= gTakt44;

fbBahn_Riem2.IsTHandVor:=
	bI_FreigabeHandVorZurueck_Riem2
	AND ( bI_AufFoerderhoehe_Riem2
		OR	fbBahn_Riem2.OsBahnAufFoerderhoehe
			AND	bI_Testbetrieb )
	AND ( strIO_GLmHand.bI_Vor
			AND NOT bI_VorZurueckInversHand
		OR	strIO_GLmHand.bI_Zurueck
			AND	bI_VorZurueckInversHand );

fbBahn_Riem2.IsTHandZurueck:=
	bI_FreigabeHandVorZurueck_Riem2
	AND	bI_BahnDarfZurueckHand_Riem2
	AND ( bI_AufFoerderhoehe_Riem2
			OR	fbBahn_Riem2.OsBahnAufFoerderhoehe
				AND	bI_Testbetrieb )
	AND ( strIO_GLmHand.bI_Zurueck
			AND NOT bI_VorZurueckInversHand
		OR	strIO_GLmHand.bI_Vor
			AND	bI_VorZurueckInversHand );

fbBahn_Riem2.IsTHandHeben:= FALSE;

fbBahn_Riem2.IsTHandSenken:= FALSE;



(* Eingänge: Sicherheit / Störung / Quittierung *)
fbBahn_Riem2.IsReset:=
	bI_FreigabeReset
	AND	strIO_GLmHand.bI_Reset;

fbBahn_Riem2.IsQuittStoerung:=
	strIO_GLmHand.bI_QuittStoerung;

fbBahn_Riem2.IsStoerungAntrieb:=
	( bI_StoerungAntrieb_Riem2
	OR	fbRampe_Riem2.bQ_Error )
	AND NOT bI_Testbetrieb;

fbBahn_Riem2.IsSicherheitOK:=
	bI_SicherheitOK
	OR 	bI_Testbetrieb;



(* Eingänge: Hardware *)
fbBahn_Riem2.IsAnfangBahn:=
	fbEntprellenAnfang_Riem2.OsSensor
	OR	bSwAnfang_Riem2
	OR	fbEntprellenAnfang_Riem1.OsSensor
		AND	strIO_GHdshk_Riem1.b_SektionenKoppelnInY;

fbBahn_Riem2.IsEndeBahn:=
	fbEntprellenEnde_Riem2.OsSensor
	OR	bSwEnde_Riem2
	OR	fbEntprellenEnde_Riem1.OsSensor
		AND	strIO_GHdshk_Riem1.b_SektionenKoppelnInY;

fbBahn_Riem2.IsBelegtVorAnfangBahn:=
	fbEntprellenVorAnfang_Riem2.OsSensor
	OR	bSwVorAnfang_Riem2;

fbBahn_Riem2.IsBelegtVorEndeBahn:=
	fbEntprellenVorEnde_Riem2.OsSensor
	OR	bSwVorEnde_Riem2;

fbBahn_Riem2.IsMitteBahn:=
	strIO_TrE.iAnzahlPlatten > 0							(* es gibt noch Platten auf der Bahn *)
	AND	strIO_TrE.asBarcode[1] <> '';						(* Daten vorhanden *)

fbBahn_Riem2.IsBahnIstAufFoerderhoehe	:= ( bI_AufFoerderhoehe_Riem2
								OR	fbBahn_Riem2.OsBahnAufFoerderhoehe
									AND	bI_Testbetrieb )
								AND ( NOT strIO_GHdshk_Riem1.b_SektionenKoppelnInY
									OR	bI_AufFoerderhoehe_Riem1
									OR	fbBahn_Riem1.OsBahnAufFoerderhoehe
										AND	bI_Testbetrieb );
fbBahn_Riem2.IsTestbetrieb			:= bI_Testbetrieb;
fbBahn_Riem2.IsFreigabe_FahrtInGrund	:= TRUE;

fbBahn_Riem2.IsFreimeldungVonVorsektion:=
	( strIO_GHdshk_Riem1_Vorg.b_FreimeldungAnNachSektion
		AND	strIO_GHdshk_Riem1_Vorg.b_BahnIstAufFoerderhoehe
		AND	bI_VorgRiemHatNurEineSpur )
	OR ( strIO_GHdshk_Riem2_Vorg.b_FreimeldungAnNachSektion
		AND	strIO_GHdshk_Riem2_Vorg.b_BahnIstAufFoerderhoehe
		AND NOT bI_VorgRiemHatNurEineSpur )
	OR ( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
		AND	fbGeberHandling_VonBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_VonBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rFreigabeFahrenRestwegVonBahn
		AND NOT fbBahn_Riem2.IsAnfangBahn );

fbBahn_Riem2.IsFreimeldungVonNachsektion:=
	( strIO_GHdshk_Riem1_Nachf.b_FreimeldungAnVorSektion
		AND	strIO_GHdshk_Riem1_Nachf.b_BahnIstAufFoerderhoehe
		AND	bI_NachfRiemHatNurEineSpur )
	OR ( strIO_GHdshk_Riem2_Nachf.b_FreimeldungAnVorSektion
		AND	strIO_GHdshk_Riem2_Nachf.b_BahnIstAufFoerderhoehe
		AND NOT bI_NachfRiemHatNurEineSpur )
	OR ( fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
		AND	fbGeberHandling_VonBahn_Riem2.OwPosiRestWert > 0
		AND	fbGeberHandling_VonBahn_Riem2.OwPosiRestWert < strIO_GHdshk_Riem2.str_Bahndaten.rFreigabeFahrenRestwegVonBahn
		AND NOT fbBahn_Riem2.IsEndeBahn );


(* Eingänge: Zusatzmodule *)
fbBahn_Riem2.IsPosi_Aktiv_AufBahn:= fbGeberHandling_AufBahn_Riem2.OsAktiv;
fbBahn_Riem2.IsPosi_Fertig_AufBahn:= fbGeberHandling_AufBahn_Riem2.OsFertig
							OR	bI_AbbruchPosi_AufBahn_Riem2
								AND ( fbBahn_Riem2.SKet1 = 104
									OR	fbBahn_Riem2.SKet1 = 144
									OR	fbBahn_Riem2.SKet1 = 152
									OR	fbBahn_Riem2.SKet1 = 704
									OR	fbBahn_Riem2.SKet1 = 826
									OR	fbBahn_Riem2.SKet1 = 920 );

fbBahn_Riem2.IsPosi_Aktiv_VonBahn:= fbGeberHandling_VonBahn_Riem2.OsAktiv;
fbBahn_Riem2.IsPosi_Fertig_VonBahn:= fbGeberHandling_VonBahn_Riem2.OsFertig
							OR	bI_AbbruchPosi_VonBahn_Riem2
								AND ( fbBahn_Riem2.SKet2 = 314
									OR	fbBahn_Riem2.SKet2 = 354
									OR	fbBahn_Riem2.SKet2 = 754
									OR	fbBahn_Riem2.SKet2 = 759 );

fbBahn_Riem2.IsLaderHatPlatteGeholt		:= strIO_GHdshk_Riem2.b_HatPlatteGeholt;
fbBahn_Riem2.IsLaderHatPlatteAbgelegt	:= strIO_GHdshk_Riem2.b_HatPlatteAbgelegt;]]></ST>
      </Implementation>
    </Action>
    <Action Name="C_Eingaenge_Roll1" Id="{96816c7f-875e-437f-bcdc-bf314ad47f9f}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Eingänge																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
IF	bI_Testbetrieb
THEN
	strIO_GHdshk_Roll1.str_Bahndaten.rWegStopVorBahnAnfang:= 0;
	strIO_GHdshk_Roll1.str_Bahndaten.rWegStopVorBahnEnde:= 0;
END_IF;

bSwAnfang_Roll1:=
	( strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
		>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
			- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
			- strIO_GHdshk_Roll1.str_Bahndaten.rWegStopVorBahnAnfang ))
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
	AND 	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Roll1.str_DoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Roll1.str_Bahndaten.rWegStopVorBahnAnfang > 0
	AND 	strIO_TrE.iAnzahlPlatten > 0
	AND ( iBahnLetzteBewegung_Sek_1 = 2
		OR	iBahnLetzteBewegung_Sek_2 = 2 );

bSwEnde_Roll1:=
	( strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
		>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
			- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
			- strIO_GHdshk_Roll1.str_Bahndaten.rWegStopVorBahnEnde ))
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnVorlauf
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiVorlauf
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnRuecklauf
	AND 	fbBahn_Roll1.OwJobAktiv_VonBahn <> eRolljobVonBahnPosiRuecklauf
	AND 	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Roll1.str_DoJob_VonBahn = eRolljobKeinJob
	AND 	strIO_GHdshk_Roll1.str_Bahndaten.rWegStopVorBahnEnde > 0
	AND 	strIO_TrE.iAnzahlPlatten > 0
	AND ( iBahnLetzteBewegung_Sek_1 = 1
		OR	iBahnLetzteBewegung_Sek_2 = 1 );

bSwVorAnfang_Roll1:=
	( fbBahn_Roll1.xFahrtInGrund										(* Slow Speed bei Fahrt in Grund und ans Bahnende *)
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAnBahnanfangRuecklauf
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Roll1.OwJobAktiv_VonBahn  = eRolljobAnBahnanfangRuecklauf
		AND	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnMittigRuecklauf
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnRuecklauf
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1] > 0
		AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
			>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
				- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiAnfang_AnfangBahn
				- strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )
		AND ( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob
				OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobAnBahnanfangRuecklauf
				OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnRuecklauf
					AND ( NOT strIO_GHdshk_Roll1_Vorg.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Roll1_Vorg.b_FreimeldungAnNachSektion )
				OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
					AND ( NOT strIO_GHdshk_Roll1_Vorg.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Roll1_Vorg.b_FreimeldungAnNachSektion ))
		AND NOT bI_Testbetrieb ))
	AND NOT strIO_GHdshk_Roll1.b_BahnSteht;

bSwVorEnde_Roll1:=
	( fbBahn_Roll1.xFahrtInGrund										(* Slow Speed bei Fahrt in Grund und ans Bahnende *)
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAnsBahnendeVorlauf
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobAnsBahnendeVorlauf
		AND	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobKeinJob
		AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1] = 0 )
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnMittigVorlauf
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnVorlauf
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_AufBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Positionierung
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob )
	OR ( strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1] > 0
		AND	strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1]
			>	( strIO_GHdshk_Roll1.str_Bahndaten.rGesamtLaenge
				- strIO_GHdshk_Roll1.str_Bahndaten.rAbstand_LiEnde_EndeBahn
				- strIO_GHdshk_Roll1.str_Bahndaten.rWegSchleichenVorStop_Ende_Anfang )
		AND ( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob
				OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobAnsBahnendeVorlauf
				OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnVorlauf
					AND ( NOT strIO_GHdshk_Roll1_Nachf.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Roll1_Nachf.b_FreimeldungAnVorSektion )
				OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
					AND ( NOT strIO_GHdshk_Roll1_Nachf.b_BahnIstAufFoerderhoehe
						OR NOT strIO_GHdshk_Roll1_Nachf.b_FreimeldungAnVorSektion ))
		AND NOT bI_Testbetrieb ))
	AND NOT strIO_GHdshk_Roll1.b_BahnSteht;

(* Eingänge: Hand / Automatik *)
fbBahn_Roll1.IwBahnName:= strIO_GHdshk_Roll1.s_Name;

fbBahn_Roll1.IsHand:= bI_Hand;

fbBahn_Roll1.IsAutomatik:= bI_Automatik;

fbBahn_Roll1.IsFreigabe_Automatik:= ( bI_AufFoerderhoehe_Roll1
							OR	fbBahn_Roll1.OsBahnAufFoerderhoehe
								AND	bI_Testbetrieb )
						AND	bI_FreigabeAutomatik
						OR	fbBahn_Roll1.xFahrtInGrund
						OR	fbBahn_Roll1.SKet1 = 50
						OR	fbBahn_Roll1.OwBahnStatus = iAutomatikBereitJob;

fbBahn_Roll1.IsDauerlauf_Aktivieren:=
	( bI_FreigabeHandVorZurueck_Roll1
		OR	bI_FreigabeHandHebenSenkenSek1
		OR	bI_FreigabeHandHebenSenkenSek2 )
	AND	gxDauerlauf_Aktiv;

fbBahn_Roll1.IsHand_Takt:= gTakt44;

fbBahn_Roll1.IsTHandVor:=
	bI_FreigabeHandVorZurueck_Roll1
	AND ( bI_AufFoerderhoehe_Roll1
			OR	fbBahn_Roll1.OsBahnAufFoerderhoehe
				AND	bI_Testbetrieb )
	AND ( strIO_GLmHand.bI_Vor
			AND NOT bI_VorZurueckInversHand
		OR	strIO_GLmHand.bI_Zurueck
			AND	bI_VorZurueckInversHand );

fbBahn_Roll1.IsTHandZurueck:=
	bI_FreigabeHandVorZurueck_Roll1
	AND	bI_BahnDarfZurueckHand_Roll1
	AND ( bI_AufFoerderhoehe_Roll1
			OR	fbBahn_Roll1.OsBahnAufFoerderhoehe
				AND	bI_Testbetrieb )
	AND ( strIO_GLmHand.bI_Zurueck
			AND NOT bI_VorZurueckInversHand
		OR	strIO_GLmHand.bI_Vor
			AND	bI_VorZurueckInversHand );

fbBahn_Roll1.IsTHandHeben:=
	( bI_FreigabeHandHebenSenkenSek1
		OR	bI_FreigabeHandHebenSenkenSek2 )
	AND	strIO_GLmHand.bI_Heben;

fbBahn_Roll1.IsTHandSenken:=
	( bI_FreigabeHandHebenSenkenSek1
		OR	bI_FreigabeHandHebenSenkenSek2 )
	AND	strIO_GLmHand.bI_Senken;



(* Eingänge: Sicherheit / Störung / Quittierung *)
fbBahn_Roll1.IsReset:=
	bI_FreigabeReset
	AND	strIO_GLmHand.bI_Reset;

fbBahn_Roll1.IsQuittStoerung:=
	strIO_GLmHand.bI_QuittStoerung;

fbBahn_Roll1.IsStoerungAntrieb:=
	( bI_StoerungAntrieb_Roll1
	OR	fbRampe_Roll1.bQ_Error )
	AND NOT bI_Testbetrieb;

fbBahn_Roll1.IsSicherheitOK:=
	bI_SicherheitOK
	OR 	bI_Testbetrieb;



(* Eingänge: Hardware *)
fbBahn_Roll1.IsAnfangBahn:=
	fbEntprellenAnfang_Roll1.OsSensor
	OR	bSwAnfang_Roll1;

fbBahn_Roll1.IsEndeBahn:=
	fbEntprellenEnde_Roll1.OsSensor
	OR	bSwEnde_Roll1;

fbBahn_Roll1.IsBelegtVorAnfangBahn:=
	fbEntprellenVorAnfang_Roll1.OsSensor
	OR	bSwVorAnfang_Roll1;

fbBahn_Roll1.IsBelegtVorEndeBahn:=
	fbEntprellenVorEnde_Roll1.OsSensor
	OR	bSwVorEnde_Roll1;

fbBahn_Roll1.IsMitteBahn:=
	strIO_TrE.iAnzahlPlatten > 0							(* es gibt noch Platten auf der Bahn *)
	AND	strIO_TrE.asBarcode[1] <> '';						(* Daten vorhanden *)

fbBahn_Roll1.IsBahnIstAufFoerderhoehe	:= bI_AufFoerderhoehe_Roll1
								OR	fbBahn_Roll1.OsBahnAufFoerderhoehe
									AND	bI_Testbetrieb;
fbBahn_Roll1.IsTestbetrieb			:= bI_Testbetrieb;
fbBahn_Roll1.IsFreigabe_FahrtInGrund	:= TRUE;

fbBahn_Roll1.IsFreimeldungVonVorsektion:=
	( strIO_GHdshk_Roll1_Vorg.b_FreimeldungAnNachSektion
		AND	strIO_GHdshk_Roll1_Vorg.b_BahnIstAufFoerderhoehe )
	OR ( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf
		AND	fbGeberHandling_VonBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_VonBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn
		AND NOT fbBahn_Roll1.IsAnfangBahn );

fbBahn_Roll1.IsFreimeldungVonNachsektion:=
	( strIO_GHdshk_Roll1_Nachf.b_FreimeldungAnVorSektion
		AND	strIO_GHdshk_Roll1_Nachf.b_BahnIstAufFoerderhoehe )
	OR ( fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
		AND	fbGeberHandling_VonBahn_Roll1.OwPosiRestWert > 0
		AND	fbGeberHandling_VonBahn_Roll1.OwPosiRestWert < strIO_GHdshk_Roll1.str_Bahndaten.rFreigabeFahrenRestwegVonBahn
		AND NOT fbBahn_Roll1.IsEndeBahn );


(* Eingänge: Zusatzmodule *)
fbBahn_Roll1.IsPosi_Aktiv_AufBahn:= fbGeberHandling_AufBahn_Roll1.OsAktiv;
fbBahn_Roll1.IsPosi_Fertig_AufBahn:= fbGeberHandling_AufBahn_Roll1.OsFertig
							OR	bI_AbbruchPosi_AufBahn_Roll1
								AND ( fbBahn_Roll1.SKet1 = 104
									OR	fbBahn_Roll1.SKet1 = 144
									OR	fbBahn_Roll1.SKet1 = 152
									OR	fbBahn_Roll1.SKet1 = 704
									OR	fbBahn_Roll1.SKet1 = 826
									OR	fbBahn_Roll1.SKet1 = 920 );

fbBahn_Roll1.IsPosi_Aktiv_VonBahn:= fbGeberHandling_VonBahn_Roll1.OsAktiv;
fbBahn_Roll1.IsPosi_Fertig_VonBahn:= fbGeberHandling_VonBahn_Roll1.OsFertig
							OR	bI_AbbruchPosi_VonBahn_Roll1
								AND ( fbBahn_Roll1.SKet2 = 314
									OR	fbBahn_Roll1.SKet2 = 354
									OR	fbBahn_Roll1.SKet2 = 754
									OR	fbBahn_Roll1.SKet2 = 759 );

fbBahn_Roll1.IsLaderHatPlatteGeholt		:= strIO_GHdshk_Roll1.b_HatPlatteGeholt;
fbBahn_Roll1.IsLaderHatPlatteAbgelegt	:= strIO_GHdshk_Roll1.b_HatPlatteAbgelegt;]]></ST>
      </Implementation>
    </Action>
    <Action Name="D_Bahnjob_Riem1" Id="{0fb96135-b193-43ee-87c8-786aa83003ce}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*	Wenn das Bahnmodul den Job übernommen hat und der Job ausgeführt wird, muss der Job gelöscht werden					*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

fbBahn_Riem1.IwDoJob_AufBahn:= strIO_GHdshk_Riem1.str_DoJob_AufBahn;				(* Job Auf Bahn von der Struktur in den Baustein schreiben *)
fbBahn_Riem1.IwDoJob_VonBahn:= strIO_GHdshk_Riem1.str_DoJob_VonBahn;				(* Job Von Bahn von der Struktur in den Baustein schreiben *)
fbBahn_Riem1.IwAnzahlPlatten_BeiVonBahn := strIO_GHdshk_Riem1.i_AnzahlPlattenVonBahn;	(* Azahl der Platten in den Baustein geben *)

IF	fbBahn_Riem1.IwDoJob_AufBahn > eRolljobKeinJob							(* Wenn der Baustein den Job Auf Bahn ausführt, Job in der Struktur zurücksetzen *)
	AND	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn = fbBahn_Riem1.IwDoJob_AufBahn		(* Aktiver Job in der Struktur angekommen *)
THEN
	strIO_GHdshk_Riem1.str_DoJob_AufBahn:= eRolljobKeinJob;
END_IF;

IF	fbBahn_Riem1.IwDoJob_VonBahn > eRolljobKeinJob							(* Wenn der Baustein den Job Auf Bahn ausführt, Job in der Struktur zurücksetzen *)
	AND	strIO_GHdshk_Riem1.str_JobAktiv_VonBahn = fbBahn_Riem1.IwDoJob_VonBahn		(* Aktiver Job in der Struktur angekommen *)
THEN
	strIO_GHdshk_Riem1.str_DoJob_VonBahn:= eRolljobKeinJob;
END_IF;


IF	(( fbBahn_Riem1.IsHand											(* Wenn Reset auf die Quellbahn gemacht wird, darf der Jobbaustein nicht buchen *)
		AND	fbBahn_Riem1.IsReset )
	OR	strIO_TrE.iReset <> 0 )
	AND NOT strIO_GHdshk_Riem1.b_JobVonBahnAbgebrochen
	AND 	strIO_GHdshk_Riem1.str_JobAktiv_VonBahn <> eRolljobKeinJob
	AND 	strIO_GHdshk_Riem1.str_JobAktiv_VonBahn <> eRolljobAnsBahnendeVorlauf
	AND 	strIO_GHdshk_Riem1.str_JobAktiv_VonBahn <> eRolljobAnBahnanfangRuecklauf
THEN
	strIO_GHdshk_Riem1.b_JobVonBahnAbgebrochen:= TRUE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="D_Bahnjob_Riem2" Id="{c144b625-c825-4599-a791-973f113114b1}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*	Wenn das Bahnmodul den Job übernommen hat und der Job ausgeführt wird, muss der Job gelöscht werden					*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

fbBahn_Riem2.IwDoJob_AufBahn:= strIO_GHdshk_Riem2.str_DoJob_AufBahn;				(* Job Auf Bahn von der Struktur in den Baustein schreiben *)
fbBahn_Riem2.IwDoJob_VonBahn:= strIO_GHdshk_Riem2.str_DoJob_VonBahn;				(* Job Von Bahn von der Struktur in den Baustein schreiben *)
fbBahn_Riem2.IwAnzahlPlatten_BeiVonBahn := strIO_GHdshk_Riem2.i_AnzahlPlattenVonBahn;	(* Azahl der Platten in den Baustein geben *)

IF	fbBahn_Riem2.IwDoJob_AufBahn > eRolljobKeinJob							(* Wenn der Baustein den Job Auf Bahn ausführt, Job in der Struktur zurücksetzen *)
	AND	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = fbBahn_Riem2.IwDoJob_AufBahn		(* Aktiver Job in der Struktur angekommen *)
THEN
	strIO_GHdshk_Riem2.str_DoJob_AufBahn:= eRolljobKeinJob;
END_IF;

IF	fbBahn_Riem2.IwDoJob_VonBahn > eRolljobKeinJob							(* Wenn der Baustein den Job Auf Bahn ausführt, Job in der Struktur zurücksetzen *)
	AND	strIO_GHdshk_Riem2.str_JobAktiv_VonBahn = fbBahn_Riem2.IwDoJob_VonBahn		(* Aktiver Job in der Struktur angekommen *)
THEN
	strIO_GHdshk_Riem2.str_DoJob_VonBahn:= eRolljobKeinJob;
END_IF;


IF	(( fbBahn_Riem2.IsHand											(* Wenn Reset auf die Quellbahn gemacht wird, darf der Jobbaustein nicht buchen *)
		AND	fbBahn_Riem2.IsReset )
	OR	strIO_TrE.iReset <> 0 )
	AND NOT strIO_GHdshk_Riem2.b_JobVonBahnAbgebrochen
	AND 	strIO_GHdshk_Riem2.str_JobAktiv_VonBahn <> eRolljobKeinJob
	AND 	strIO_GHdshk_Riem2.str_JobAktiv_VonBahn <> eRolljobAnsBahnendeVorlauf
	AND 	strIO_GHdshk_Riem2.str_JobAktiv_VonBahn <> eRolljobAnBahnanfangRuecklauf
THEN
	strIO_GHdshk_Riem2.b_JobVonBahnAbgebrochen:= TRUE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="D_Bahnjob_Roll1" Id="{f197565d-b29a-4841-9297-4b9afbee23f1}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*	Wenn das Bahnmodul den Job übernommen hat und der Job ausgeführt wird, muss der Job gelöscht werden					*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

fbBahn_Roll1.IwDoJob_AufBahn:= strIO_GHdshk_Roll1.str_DoJob_AufBahn;				(* Job Auf Bahn von der Struktur in den Baustein schreiben *)
fbBahn_Roll1.IwDoJob_VonBahn:= strIO_GHdshk_Roll1.str_DoJob_VonBahn;				(* Job Von Bahn von der Struktur in den Baustein schreiben *)
fbBahn_Roll1.IwAnzahlPlatten_BeiVonBahn:= strIO_GHdshk_Roll1.i_AnzahlPlattenVonBahn;	(* Azahl der Platten in den Baustein geben *)

IF	fbBahn_Roll1.IwDoJob_AufBahn > eRolljobKeinJob							(* Wenn der Baustein den Job Auf Bahn ausführt, Job in der Struktur zurücksetzen *)
	AND	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn = fbBahn_Roll1.IwDoJob_AufBahn		(* Aktiver Job in der Struktur angekommen *)
THEN
	strIO_GHdshk_Roll1.str_DoJob_AufBahn:= eRolljobKeinJob;
END_IF;

IF	fbBahn_Roll1.IwDoJob_VonBahn > eRolljobKeinJob							(* Wenn der Baustein den Job Auf Bahn ausführt, Job in der Struktur zurücksetzen *)
	AND	strIO_GHdshk_Roll1.str_JobAktiv_VonBahn = fbBahn_Roll1.IwDoJob_VonBahn		(* Aktiver Job in der Struktur angekommen *)
THEN
	strIO_GHdshk_Roll1.str_DoJob_VonBahn:= eRolljobKeinJob;
END_IF;


IF	(( fbBahn_Roll1.IsHand											(* Wenn Reset auf die Quellbahn gemacht wird, darf der Jobbaustein nicht buchen *)
		AND	fbBahn_Roll1.IsReset )
	OR	strIO_TrE.iReset <> 0 )
	AND NOT strIO_GHdshk_Roll1.b_JobVonBahnAbgebrochen
	AND 	strIO_GHdshk_Roll1.str_JobAktiv_VonBahn <> eRolljobKeinJob
	AND 	strIO_GHdshk_Roll1.str_JobAktiv_VonBahn <> eRolljobAnsBahnendeVorlauf
	AND 	strIO_GHdshk_Roll1.str_JobAktiv_VonBahn <> eRolljobAnBahnanfangRuecklauf
THEN
	strIO_GHdshk_Roll1.b_JobVonBahnAbgebrochen:= TRUE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="E_Ausgaenge_Hub" Id="{a9db11da-a553-4d3c-8901-ace94c453a7a}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Ausgänge Hub Winkeluebergabe															*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

IF	bI_Automatik
THEN
	IF	strIO_GHdshk_Riem1.b_SektionenKoppelnInY
	THEN
		bQ_Sektion1AS:= bQ_Sektion2AS;
		bQ_Sektion1GS:= bQ_Sektion2GS;

	ELSIF	fbBahn_Roll1.OwBahnStatus = iAutomatikAktivJob
	THEN
		IF	bI_HebenSenkenInvers
		THEN
			bQ_Sektion1AS:= fbBahn_Roll1.OsBahnAufFoerderhoehe;
			bQ_Sektion1GS:= NOT fbBahn_Roll1.OsBahnAufFoerderhoehe;
		ELSE
			bQ_Sektion1AS:= NOT fbBahn_Roll1.OsBahnAufFoerderhoehe;
			bQ_Sektion1GS:= fbBahn_Roll1.OsBahnAufFoerderhoehe;
		END_IF;

	ELSIF	fbBahn_Riem1.OwBahnStatus = iAutomatikAktivJob
	THEN
		IF	bI_HebenSenkenInvers
		THEN
			bQ_Sektion1AS:= NOT fbBahn_Riem1.OsBahnAufFoerderhoehe;
			bQ_Sektion1GS:= fbBahn_Riem1.OsBahnAufFoerderhoehe;
		ELSE
			bQ_Sektion1AS:= fbBahn_Riem1.OsBahnAufFoerderhoehe;
			bQ_Sektion1GS:= NOT fbBahn_Riem1.OsBahnAufFoerderhoehe;
		END_IF;
	END_IF;

	IF	strIO_GHdshk_Riem2.b_SektionenKoppelnInY
	THEN
		bQ_Sektion2AS:= bQ_Sektion1AS;
		bQ_Sektion2GS:= bQ_Sektion1GS;

	ELSIF	fbBahn_Roll1.OwBahnStatus = iAutomatikAktivJob
	THEN
		IF	bI_HebenSenkenInvers
		THEN
			bQ_Sektion2AS:= fbBahn_Roll1.OsBahnAufFoerderhoehe;
			bQ_Sektion2GS:= NOT fbBahn_Roll1.OsBahnAufFoerderhoehe;
		ELSE
			bQ_Sektion2AS:= NOT fbBahn_Roll1.OsBahnAufFoerderhoehe;
			bQ_Sektion2GS:= fbBahn_Roll1.OsBahnAufFoerderhoehe;
		END_IF;

	ELSIF	fbBahn_Riem2.OwBahnStatus = iAutomatikAktivJob
	THEN
		IF	bI_HebenSenkenInvers
		THEN
			bQ_Sektion2AS:= NOT fbBahn_Riem2.OsBahnAufFoerderhoehe;
			bQ_Sektion2GS:= fbBahn_Riem2.OsBahnAufFoerderhoehe;
		ELSE
			bQ_Sektion2AS:= fbBahn_Riem2.OsBahnAufFoerderhoehe;
			bQ_Sektion2GS:= NOT fbBahn_Riem2.OsBahnAufFoerderhoehe;
		END_IF;
	END_IF;

	IF	fbBahn_Roll1.OwBahnStatus = iAutomatikBereitJob
		AND	fbBahn_Riem1.OwBahnStatus = iAutomatikBereitJob
		AND	fbBahn_Riem2.OwBahnStatus = iAutomatikBereitJob
		AND NOT strIO_GHdshk_Roll1.b_BahnBelegt
		AND NOT strIO_GHdshk_Riem1.b_BahnBelegt
		AND NOT strIO_GHdshk_Riem2.b_BahnBelegt
		AND strIO_TrE.iAnzahlPlatten = 0
		AND strIO_TrE.asBarcode[1] = ''
	THEN
		IF	bI_HubGrundWennFrei_Sek_1
		THEN
			bQ_Sektion1AS:= FALSE;
			bQ_Sektion1GS:= TRUE;

		ELSIF bI_HubArbeitWennFrei_Sek_1
		THEN
			bQ_Sektion1AS:= TRUE;
			bQ_Sektion1GS:= FALSE;
		END_IF;

		IF	bI_HubGrundWennFrei_Sek_2
		THEN
			bQ_Sektion2AS:= FALSE;
			bQ_Sektion2GS:= TRUE;

		ELSIF bI_HubArbeitWennFrei_Sek_2
		THEN
			bQ_Sektion2AS:= TRUE;
			bQ_Sektion2GS:= FALSE;
		END_IF;

	ELSIF	fbBahn_Roll1.OwBahnStatus = iAutomatikBereitJob
		AND	fbBahn_Riem1.OwBahnStatus = iAutomatikBereitJob
		AND	fbBahn_Riem2.OwBahnStatus = iAutomatikBereitJob
		AND 	strIO_GHdshk_Roll1.b_BahnBelegt
		AND 	strIO_GHdshk_Riem1.b_BahnBelegt
		AND 	strIO_GHdshk_Riem2.b_BahnBelegt
		AND 	strIO_TrE.iAnzahlPlatten = 0
		AND 	strIO_TrE.asBarcode[1] = ''
	THEN
		IF	bI_HubGrundWennBelegt_Sek_1
		THEN
			bQ_Sektion1AS:= FALSE;
			bQ_Sektion1GS:= TRUE;

		ELSIF bI_HubArbeitWennBelegt_Sek_1
		THEN
			bQ_Sektion1AS:= TRUE;
			bQ_Sektion1GS:= FALSE;
		END_IF;

		IF	bI_HubGrundWennBelegt_Sek_2
		THEN
			bQ_Sektion2AS:= FALSE;
			bQ_Sektion2GS:= TRUE;

		ELSIF bI_HubArbeitWennBelegt_Sek_2
		THEN
			bQ_Sektion2AS:= TRUE;
			bQ_Sektion2GS:= FALSE;
		END_IF;
	END_IF;

	bHandHebenSenkenAktiv_Sek_1:= FALSE;
	bHandHebenSenkenAktiv_Sek_2:= FALSE;

ELSIF	bI_Hand
THEN
	IF	( strIO_GLmHand.bI_Heben
		OR	strIO_GLmHand.bI_Senken )
		AND	bI_FreigabeHandHebenSenkenSek1
	THEN
		bHandHebenSenkenAktiv_Sek_1:= TRUE;
	END_IF;

	IF	( strIO_GLmHand.bI_Heben
		OR	strIO_GLmHand.bI_Senken )
		AND	bI_FreigabeHandHebenSenkenSek2
	THEN
		bHandHebenSenkenAktiv_Sek_2:= TRUE;
	END_IF;

	IF	bHandHebenSenkenAktiv_Sek_1
	THEN
		bQ_Sektion1AS:= fbBahn_Roll1.OsBahnAufFoerderhoehe;
		bQ_Sektion1GS:= NOT fbBahn_Roll1.OsBahnAufFoerderhoehe;
	END_IF;

	IF	bHandHebenSenkenAktiv_Sek_2
	THEN
		bQ_Sektion2AS:= fbBahn_Roll1.OsBahnAufFoerderhoehe;
		bQ_Sektion2GS:= NOT fbBahn_Roll1.OsBahnAufFoerderhoehe;
	END_IF;

ELSE
	bHandHebenSenkenAktiv_Sek_1:= FALSE;
	bHandHebenSenkenAktiv_Sek_2:= FALSE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="E_Ausgaenge_Riem1" Id="{4bf71f4f-bbac-4148-ac7c-55aefdc24bb1}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Ausgänge																											*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
fbRampe_Riem1(
	lrI_Acceleration:= strIO_GHdshk_Riem1.str_BahnRampen.lrBeschleunigung_mms2,
	lrI_Deceleration:= strIO_GHdshk_Riem1.str_BahnRampen.lrVerzoegerung_mms2,
	lrI_FastDeceleration:= strIO_GHdshk_Riem1.str_BahnRampen.lrNotverzoegerung_mms2,
	lrI_TimeBase:= lrZyklusZeit_SPS,
	lrI_MaxVelo:= strIO_GHdshk_Riem1.str_BahnSpeed.rVmaxSpeed,
	lrI_Velocity:= fbBahn_Riem1.OwBahnSpeed,
	lrI_CoupleVelocity:= fbBahn_Riem2.OwBahnSpeed,
	lrI_CoupleAcceleration:= strIO_GHdshk_Riem2.str_BahnRampen.lrBeschleunigung_mms2,
	lrI_CoupleDeceleration:= strIO_GHdshk_Riem2.str_BahnRampen.lrVerzoegerung_mms2,
	bI_Couple:= strIO_GHdshk_Riem1.b_SektionenKoppelnInY
			AND	bI_Automatik,
	bI_Enable:= bI_SicherheitOK,
	bI_ErrorQuit:= strIO_GLmHand.bI_QuittStoerung,
	lrQ_ActVelocity=> ,
	uiQ_ErrorNumber=> , 
	iQ_AnalogueValue=> ,
	bQ_TargetVelo=> , 
	bQ_Acceleration=> ,
	bQ_Deceleration=> ,
	bQ_MovePos=> , 
	bQ_MoveNeg=> , 
	bQ_MoveNot=> ,
	bQ_Error=> );

IF	fbRampe_Riem1.bQ_MovePos
THEN
	iBahnLetzteBewegung_Sek_1:= 11;

ELSIF	fbRampe_Riem1.bQ_MoveNeg
THEN
	iBahnLetzteBewegung_Sek_1:= 12;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="E_Ausgaenge_Riem2" Id="{eb0f9453-6053-4c22-95f9-26675c356495}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Ausgänge																											*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
fbRampe_Riem2(
	lrI_Acceleration:= strIO_GHdshk_Riem2.str_BahnRampen.lrBeschleunigung_mms2,
	lrI_Deceleration:= strIO_GHdshk_Riem2.str_BahnRampen.lrVerzoegerung_mms2,
	lrI_FastDeceleration:= strIO_GHdshk_Riem2.str_BahnRampen.lrNotverzoegerung_mms2,
	lrI_TimeBase:= lrZyklusZeit_SPS,
	lrI_MaxVelo:= strIO_GHdshk_Riem2.str_BahnSpeed.rVmaxSpeed,
	lrI_Velocity:= fbBahn_Riem2.OwBahnSpeed,
	lrI_CoupleVelocity:= fbBahn_Riem1.OwBahnSpeed,
	lrI_CoupleAcceleration:= strIO_GHdshk_Riem1.str_BahnRampen.lrBeschleunigung_mms2,
	lrI_CoupleDeceleration:= strIO_GHdshk_Riem1.str_BahnRampen.lrVerzoegerung_mms2,
	bI_Couple:= strIO_GHdshk_Riem2.b_SektionenKoppelnInY
			AND	bI_Automatik,
	bI_Enable:= bI_SicherheitOK,
	bI_ErrorQuit:= strIO_GLmHand.bI_QuittStoerung,
	lrQ_ActVelocity=> ,
	uiQ_ErrorNumber=> , 
	iQ_AnalogueValue=> ,
	bQ_TargetVelo=> , 
	bQ_Acceleration=> ,
	bQ_Deceleration=> ,
	bQ_MovePos=> ,
	bQ_MoveNeg=> ,
	bQ_MoveNot=> ,
	bQ_Error=> );

IF	fbRampe_Riem2.bQ_MovePos
THEN
	iBahnLetzteBewegung_Sek_2:= 11;

ELSIF	fbRampe_Riem2.bQ_MoveNeg
THEN
	iBahnLetzteBewegung_Sek_2:= 12;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="E_Ausgaenge_Roll1" Id="{10edfa06-3159-46ca-aecb-841c62febae4}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Ausgänge																											*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
fbRampe_Roll1(
	lrI_Acceleration:= strIO_GHdshk_Roll1.str_BahnRampen.lrBeschleunigung_mms2,
	lrI_Deceleration:= strIO_GHdshk_Roll1.str_BahnRampen.lrVerzoegerung_mms2,
	lrI_FastDeceleration:= strIO_GHdshk_Roll1.str_BahnRampen.lrNotverzoegerung_mms2,
	lrI_TimeBase:= lrZyklusZeit_SPS,
	lrI_MaxVelo:= strIO_GHdshk_Roll1.str_BahnSpeed.rVmaxSpeed,
	lrI_Velocity:= fbBahn_Roll1.OwBahnSpeed,
	lrI_CoupleVelocity:= 0,
	lrI_CoupleAcceleration:= 0,
	lrI_CoupleDeceleration:= 0,
	bI_Couple:= FALSE,
	bI_Enable:= bI_SicherheitOK,
	bI_ErrorQuit:= strIO_GLmHand.bI_QuittStoerung,
	lrQ_ActVelocity=> ,
	uiQ_ErrorNumber=> ,
	iQ_AnalogueValue=> ,
	bQ_TargetVelo=> , 
	bQ_Acceleration=> , 
	bQ_Deceleration=> ,
	bQ_MovePos=> ,
	bQ_MoveNeg=> , 
	bQ_MoveNot=> ,
	bQ_Error=> );

IF	fbRampe_Roll1.bQ_MovePos
THEN
	iBahnLetzteBewegung_Sek_1:= 1;
	iBahnLetzteBewegung_Sek_2:= 1;

ELSIF	fbRampe_Roll1.bQ_MoveNeg
THEN
	iBahnLetzteBewegung_Sek_1:= 2;
	iBahnLetzteBewegung_Sek_2:= 2;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="F_Positionierung_Riem1" Id="{2dd52e60-e480-4bdd-a712-fd40bc5bee57}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Positionierung																	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)


(*------ Achse Istwertsetzen  ---------------------------------*)
IF	uiI_AxId_Riem1 <> 0
THEN
	IF	fbBahn_Riem1.IwDoJob_AufBahn = eRolljobKeinJob
		AND	fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobKeinJob
		AND	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobKeinJob
		AND	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	fbAxIstwert_Riem1.OwOut.eAchsStatus = eStatAchse_BereitFuerJob
		AND NOT strIO_GHdshk_Riem1.b_BahnBelegt
		AND	strIO_TrE.iAnzahlPlatten = 0
		AND	strIO_TrE.asBarcode[1] = ''
		AND NOT bIstwertSetzen_Riem1
		AND ( AxFrNc_fPosIst[uiI_AxId_Riem1] > 50000
			OR	AxFrNc_fPosIst[uiI_AxId_Riem1] < -50000 )
	THEN
		bIstwertSetzen_Riem1:= TRUE;
	END_IF;

	fbAxIstwert_Riem1.AxId:= uiI_AxId_Riem1;
	fbAxIstwert_Riem1.IwResetMode:= 0;		(* Reset Modul *)

	fbAxIstwert_Riem1.IsHand:= bI_Hand;

	fbAxIstwert_Riem1.IsResetNachNotHalt:=
		AxFrNcFehler[uiI_AxId_Riem1]
		AND 	strIO_GLmHand.bI_QuittStoerung;

	fbAxIstwert_Riem1.IsAxFrNc_Auftraglaeuft:= AxFrNcAuftraglaeuft[uiI_AxId_Riem1];
	fbAxIstwert_Riem1.IsAxFrNc_Steht:= AxFrNcSteht[uiI_AxId_Riem1];
	fbAxIstwert_Riem1.IsAxFrNc_Geeicht:= AxFrNcGeeicht[uiI_AxId_Riem1];
	fbAxIstwert_Riem1.IsAxFrNc_Fehler:= AxFrNcFehler[uiI_AxId_Riem1];
	fbAxIstwert_Riem1.IwAxFrNc_nErrorCode:= AxFrNc_nErrorCode[uiI_AxId_Riem1];
	fbAxIstwert_Riem1.IsModuloAchse:= FALSE;
	
	fbAxIstwert_Riem1.IsReset:=
		( bI_FreigabeHandVorZurueck_Riem1
			OR	bI_FreigabeReset )
		AND	strIO_GLmHand.bI_Reset;
	
	IF	bIstwertSetzen_Riem1
		AND NOT fbAxIstwert_Riem1.IsIstwertSetzen
	THEN
		fbAxIstwert_Riem1.IsIstwertSetzen:= TRUE;
		fbAxIstwert_Riem1.IwWertIstwertSetzen:= 0;
	END_IF;
	
	IF	fbAxIstwert_Riem1.IsIstwertSetzen
		AND	fbAxIstwert_Riem1.OwOut.xIstwertGesetzt
	THEN
		fbAxIstwert_Riem1.IsIstwertSetzen:= FALSE;
		bIstwertSetzen_Riem1:= FALSE;
		lrIstwert_Bahn_Riem1:= 0;
	END_IF;


		fbAxIstwert_Riem1();

(*------ Simulation Istwert  ---------------------------------*)

	IF	bI_Testbetrieb
	THEN
		IF	strIO_GHdshk_Riem1.b_BahnVor
		THEN
			lrIstwert_Bahn_Riem1:=
				lrIstwert_Bahn_Riem1
				+ ABS((( strIO_GHdshk_Riem1.lr_Bahnspeed_Vorgabe * 1000) / 60 ) * lrZyklusZeit_SPS );
	
		ELSIF strIO_GHdshk_Riem1.b_BahnZurueck
		THEN
			lrIstwert_Bahn_Riem1:=
				lrIstwert_Bahn_Riem1
				- ABS((( strIO_GHdshk_Riem1.lr_Bahnspeed_Vorgabe * 1000) / 60 ) * lrZyklusZeit_SPS );
		END_IF;
	
		AxFrNc_fPosIst[uiI_AxId_Riem1]:= LREAL_TO_REAL ( lrIstwert_Bahn_Riem1 );
	END_IF;
END_IF;

IF ( bI_Testbetrieb
	OR	bI_OhneImpulsgeber_Riem1 )
	AND	uiI_AxId_Riem1 = 0
THEN
	fbVirtuellerImpulsgeber_Riem1(
		bI_Start:= strIO_GHdshk_Riem1.b_BahnVor
				OR	strIO_GHdshk_Riem1.b_BahnZurueck,
		lrI_TimeBase:= lrZyklusZeit_SPS,
		lrI_Speed:= ABS(strIO_GHdshk_Riem1.lr_Bahnspeed_Vorgabe),
		lrI_WegProImpuls:= strIO_GHdshk_Riem1.str_Bahndaten.rWegProImpuls,
		IO_Impulse:= iIncGeberZaehler_Riem1 );
END_IF;

(*------ AufBahn Positionierung Bahn  ---------------------------------*)
IF	uiI_AxId_Riem1 <> 0
THEN
	fbGeberHandling_AufBahn_Riem1.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_AufBahn_Riem1.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Riem1];
	fbGeberHandling_AufBahn_Riem1.IwIncGeberZaehler:= 0;
	fbGeberHandling_AufBahn_Riem1.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_AufBahn_Riem1.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_AufBahn_Riem1.IwIstwert:= 0;
	fbGeberHandling_AufBahn_Riem1.IwIncGeberZaehler:= iIncGeberZaehler_Riem1;
	fbGeberHandling_AufBahn_Riem1.IwWegProImpuls:= strIO_GHdshk_Riem1.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_AufBahn_Riem1.IsAnfangBahn:= fbBahn_Riem1.IsAnfangBahn;
fbGeberHandling_AufBahn_Riem1.IsEndeBahn:= fbBahn_Riem1.IsEndeBahn;
fbGeberHandling_AufBahn_Riem1.IsStart:= fbBahn_Riem1.OsPosi_Start_AufBahn;
fbGeberHandling_AufBahn_Riem1.IsIncGeber:=  FALSE;
fbGeberHandling_AufBahn_Riem1.IsRestwertSchreiben:= TRUE;

fbGeberHandling_AufBahn_Riem1.IsIstwertGesetzt:= FALSE;
fbGeberHandling_AufBahn_Riem1.IsImRuecklauf:=
	fbBahn_Riem1.IwDoJob_AufBahn = eRolljobAufBahnPosiRuecklauf
	OR	fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf;

fbGeberHandling_AufBahn_Riem1.IsPosiAufBahn:=
	fbBahn_Riem1.IwDoJob_AufBahn = eRolljobAufBahnPosiVorlauf
	OR	fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf
	OR	fbBahn_Riem1.IwDoJob_AufBahn = eRolljobAufBahnPosiRuecklauf
	OR	fbBahn_Riem1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf;

fbGeberHandling_AufBahn_Riem1.IsPosiVonBahn:= FALSE;

fbGeberHandling_AufBahn_Riem1.IsPosi_AufDerBahn:=
	NOT fbGeberHandling_AufBahn_Riem1.IsPosiAufBahn
	AND NOT fbGeberHandling_AufBahn_Riem1.IsPosiVonBahn;

fbGeberHandling_AufBahn_Riem1.IsTestbetrieb:= bI_Testbetrieb;
fbGeberHandling_AufBahn_Riem1.IwZielPosition:= strIO_GHdshk_Riem1.r_ZielAufBahn;
fbGeberHandling_AufBahn_Riem1 ( IO_IstwertSetzen:= gxNop );


(*------ VonBahn Positionierung Bahn  ---------------------------------*)
IF	uiI_AxId_Riem1 <> 0
THEN
	fbGeberHandling_VonBahn_Riem1.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_VonBahn_Riem1.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Riem1];
	fbGeberHandling_VonBahn_Riem1.IwIncGeberZaehler:= 0;
	fbGeberHandling_VonBahn_Riem1.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_VonBahn_Riem1.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_VonBahn_Riem1.IwIstwert:= 0;
	fbGeberHandling_VonBahn_Riem1.IwIncGeberZaehler:= iIncGeberZaehler_Riem1;
	fbGeberHandling_VonBahn_Riem1.IwWegProImpuls:= strIO_GHdshk_Riem1.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_VonBahn_Riem1.IsAnfangBahn:= fbBahn_Riem1.IsAnfangBahn;
fbGeberHandling_VonBahn_Riem1.IsEndeBahn:= fbBahn_Riem1.IsEndeBahn;
fbGeberHandling_VonBahn_Riem1.IsStart:= fbBahn_Riem1.OsPosi_Start_VonBahn;
fbGeberHandling_VonBahn_Riem1.IsIncGeber:=  FALSE;
fbGeberHandling_VonBahn_Riem1.IsRestwertSchreiben:= TRUE;

fbGeberHandling_VonBahn_Riem1.IsIstwertGesetzt:= FALSE;
fbGeberHandling_VonBahn_Riem1.IsImRuecklauf:=
	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf
	OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf;

fbGeberHandling_VonBahn_Riem1.IsPosiAufBahn:= FALSE;
fbGeberHandling_VonBahn_Riem1.IsPosiVonBahn:=
	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobVonBahnPosiVorlauf
	OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
	OR	fbBahn_Riem1.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf
	OR	fbBahn_Riem1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf;

fbGeberHandling_VonBahn_Riem1.IsPosi_AufDerBahn:=
	NOT fbGeberHandling_VonBahn_Riem1.IsPosiVonBahn;

fbGeberHandling_VonBahn_Riem1.IsTestbetrieb:= bI_Testbetrieb;
fbGeberHandling_VonBahn_Riem1.IwZielPosition:= strIO_GHdshk_Riem1.r_ZielVonBahn;
fbGeberHandling_VonBahn_Riem1 ( IO_IstwertSetzen:= gxNop );


(*------ Position auf der Bahn  ---------------------------------*)
IF	uiI_AxId_Riem1 <> 0
THEN
	fbGeberHandling_PosPlatte_Riem1.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_PosPlatte_Riem1.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Riem1];
	fbGeberHandling_PosPlatte_Riem1.IwIncGeberZaehler:= 0;
	fbGeberHandling_PosPlatte_Riem1.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_PosPlatte_Riem1.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_PosPlatte_Riem1.IwIstwert:= 0;
	fbGeberHandling_PosPlatte_Riem1.IwIncGeberZaehler:= iIncGeberZaehler_Riem1;
	fbGeberHandling_PosPlatte_Riem1.IwWegProImpuls:= strIO_GHdshk_Riem1.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_PosPlatte_Riem1.IsIncGeber:= FALSE;
fbGeberHandling_PosPlatte_Riem1.IsStart:= TRUE;
fbGeberHandling_PosPlatte_Riem1 ( IO_PlattenPos:= strIO_GHdshk_Riem1.str_PlattenPos );


(*------ Kontrolle des Registerimpulses  ---------------------------------*)
fbGeberKontrolle_Riem1.iI_Mode:= 2;
fbGeberKontrolle_Riem1.iI_MaxAbweichung:= strIO_GHdshk_Riem1.str_Bahndaten.iMaxAbweichungSkalierungRegisterimpuls;
fbGeberKontrolle_Riem1.iI_IncGeberZaehler:= iIncGeberZaehler_Riem1;
fbGeberKontrolle_Riem1.lrI_Geschwindigkeit:= ABS(strIO_GHdshk_Riem1.lr_Bahnspeed_Ist);
fbGeberKontrolle_Riem1.rI_WegProImpuls:= strIO_GHdshk_Riem1.str_Bahndaten.rWegProImpuls;
fbGeberKontrolle_Riem1.bI_AntriebLaeuft:= ( strIO_GHdshk_Riem1.b_BahnVor
							OR	strIO_GHdshk_Riem1.b_BahnZurueck )
							AND	ABS(strIO_GHdshk_Riem1.lr_Bahnspeed_Vorgabe) >= 5
							AND	uiI_AxId_Riem1 = 0;

fbGeberKontrolle_Riem1.bI_Testbetrieb:= bI_Testbetrieb;
fbGeberKontrolle_Riem1.bI_IfStreckenzaehler:= FALSE;
fbGeberKontrolle_Riem1.bI_QuittStoerung:=	strIO_GLmHand.bI_QuittStoerung;

fbGeberKontrolle_Riem1.tI_LaufzeitImpuls:= strIO_GHdshk_Riem1.str_BahnZeiten.tBisFehlerRegisterimpuls;
fbGeberKontrolle_Riem1.tI_LaufzeitMessung:= strIO_GHdshk_Riem1.str_BahnZeiten.tMesslaengeSkalierungRegisterimpuls;

fbGeberKontrolle_Riem1();]]></ST>
      </Implementation>
    </Action>
    <Action Name="F_Positionierung_Riem2" Id="{e2b11baa-2698-4b03-96e4-a66c39cf0f43}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Positionierung																	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)


(*------ Achse Istwertsetzen  ---------------------------------*)
IF	uiI_AxId_Riem2 <> 0
THEN
	IF	fbBahn_Riem2.IwDoJob_AufBahn = eRolljobKeinJob
		AND	fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobKeinJob
		AND	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobKeinJob
		AND	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	fbAxIstwert_Riem2.OwOut.eAchsStatus = eStatAchse_BereitFuerJob
		AND NOT strIO_GHdshk_Riem2.b_BahnBelegt
		AND	strIO_TrE.iAnzahlPlatten = 0
		AND	strIO_TrE.asBarcode[1] = ''
		AND NOT bIstwertSetzen_Riem2
		AND ( AxFrNc_fPosIst[uiI_AxId_Riem2] > 50000
			OR	AxFrNc_fPosIst[uiI_AxId_Riem2] < -50000 )
	THEN
		bIstwertSetzen_Riem2:= TRUE;
	END_IF;

	fbAxIstwert_Riem2.AxId:= uiI_AxId_Riem2;
	fbAxIstwert_Riem2.IwResetMode:= 0;		(* Reset Modul *)

	fbAxIstwert_Riem2.IsHand:= bI_Hand;

	fbAxIstwert_Riem2.IsResetNachNotHalt:=
		AxFrNcFehler[uiI_AxId_Riem2]
		AND 	strIO_GLmHand.bI_QuittStoerung;

	fbAxIstwert_Riem2.IsAxFrNc_Auftraglaeuft:= AxFrNcAuftraglaeuft[uiI_AxId_Riem2];
	fbAxIstwert_Riem2.IsAxFrNc_Steht:= AxFrNcSteht[uiI_AxId_Riem2];
	fbAxIstwert_Riem2.IsAxFrNc_Geeicht:= AxFrNcGeeicht[uiI_AxId_Riem2];
	fbAxIstwert_Riem2.IsAxFrNc_Fehler:= AxFrNcFehler[uiI_AxId_Riem2];
	fbAxIstwert_Riem2.IwAxFrNc_nErrorCode:= AxFrNc_nErrorCode[uiI_AxId_Riem2];
	fbAxIstwert_Riem2.IsModuloAchse:= FALSE;
	
	fbAxIstwert_Riem2.IsReset:=
		( bI_FreigabeHandVorZurueck_Riem2
			OR	bI_FreigabeReset )
		AND	strIO_GLmHand.bI_Reset;
	
	IF	bIstwertSetzen_Riem2
		AND NOT fbAxIstwert_Riem2.IsIstwertSetzen
	THEN
		fbAxIstwert_Riem2.IsIstwertSetzen:= TRUE;
		fbAxIstwert_Riem2.IwWertIstwertSetzen:= 0;
	END_IF;
	
	IF	fbAxIstwert_Riem2.IsIstwertSetzen
		AND	fbAxIstwert_Riem2.OwOut.xIstwertGesetzt
	THEN
		fbAxIstwert_Riem2.IsIstwertSetzen:= FALSE;
		bIstwertSetzen_Riem2:= FALSE;
		lrIstwert_Bahn_Riem2:= 0;
	END_IF;


		fbAxIstwert_Riem2();

(*------ Simulation Istwert  ---------------------------------*)

	IF	bI_Testbetrieb
	THEN
		IF	strIO_GHdshk_Riem2.b_BahnVor
		THEN
			lrIstwert_Bahn_Riem2:=
				lrIstwert_Bahn_Riem2
				+ ABS((( strIO_GHdshk_Riem2.lr_Bahnspeed_Vorgabe * 1000) / 60 ) * lrZyklusZeit_SPS );
	
		ELSIF strIO_GHdshk_Riem2.b_BahnZurueck
		THEN
			lrIstwert_Bahn_Riem2:=
				lrIstwert_Bahn_Riem2
				- ABS((( strIO_GHdshk_Riem2.lr_Bahnspeed_Vorgabe * 1000) / 60 ) * lrZyklusZeit_SPS );
		END_IF;
	
		AxFrNc_fPosIst[uiI_AxId_Riem2]:= LREAL_TO_REAL ( lrIstwert_Bahn_Riem2 );
	END_IF;
END_IF;

IF ( bI_Testbetrieb
	OR	bI_OhneImpulsgeber_Riem2 )
	AND	uiI_AxId_Riem2 = 0
THEN
	fbVirtuellerImpulsgeber_Riem2(
		bI_Start:= strIO_GHdshk_Riem2.b_BahnVor
				OR	strIO_GHdshk_Riem2.b_BahnZurueck,
		lrI_TimeBase:= lrZyklusZeit_SPS,
		lrI_Speed:= ABS(strIO_GHdshk_Riem2.lr_Bahnspeed_Vorgabe),
		lrI_WegProImpuls:= strIO_GHdshk_Riem2.str_Bahndaten.rWegProImpuls,
		IO_Impulse:= iIncGeberZaehler_Riem2 );
END_IF;

(*------ AufBahn Positionierung Bahn  ---------------------------------*)
IF	uiI_AxId_Riem2 <> 0
THEN
	fbGeberHandling_AufBahn_Riem2.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_AufBahn_Riem2.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Riem2];
	fbGeberHandling_AufBahn_Riem2.IwIncGeberZaehler:= 0;
	fbGeberHandling_AufBahn_Riem2.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_AufBahn_Riem2.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_AufBahn_Riem2.IwIstwert:= 0;
	fbGeberHandling_AufBahn_Riem2.IwIncGeberZaehler:= iIncGeberZaehler_Riem2;
	fbGeberHandling_AufBahn_Riem2.IwWegProImpuls:= strIO_GHdshk_Riem2.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_AufBahn_Riem2.IsAnfangBahn:= fbBahn_Riem2.IsAnfangBahn;
fbGeberHandling_AufBahn_Riem2.IsEndeBahn:= fbBahn_Riem2.IsEndeBahn;
fbGeberHandling_AufBahn_Riem2.IsStart:= fbBahn_Riem2.OsPosi_Start_AufBahn;
fbGeberHandling_AufBahn_Riem2.IsIncGeber:=  FALSE;
fbGeberHandling_AufBahn_Riem2.IsRestwertSchreiben:= TRUE;

fbGeberHandling_AufBahn_Riem2.IsIstwertGesetzt:= FALSE;
fbGeberHandling_AufBahn_Riem2.IsImRuecklauf:=
	fbBahn_Riem2.IwDoJob_AufBahn = eRolljobAufBahnPosiRuecklauf
	OR	fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf;

fbGeberHandling_AufBahn_Riem2.IsPosiAufBahn:=
	fbBahn_Riem2.IwDoJob_AufBahn = eRolljobAufBahnPosiVorlauf
	OR	fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf
	OR	fbBahn_Riem2.IwDoJob_AufBahn = eRolljobAufBahnPosiRuecklauf
	OR	fbBahn_Riem2.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf;

fbGeberHandling_AufBahn_Riem2.IsPosiVonBahn:= FALSE;

fbGeberHandling_AufBahn_Riem2.IsPosi_AufDerBahn:=
	NOT fbGeberHandling_AufBahn_Riem2.IsPosiAufBahn
	AND NOT fbGeberHandling_AufBahn_Riem2.IsPosiVonBahn;

fbGeberHandling_AufBahn_Riem2.IsTestbetrieb:= bI_Testbetrieb;
fbGeberHandling_AufBahn_Riem2.IwZielPosition:= strIO_GHdshk_Riem2.r_ZielAufBahn;
fbGeberHandling_AufBahn_Riem2 ( IO_IstwertSetzen:= gxNop );


(*------ VonBahn Positionierung Bahn  ---------------------------------*)
IF	uiI_AxId_Riem2 <> 0
THEN
	fbGeberHandling_VonBahn_Riem2.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_VonBahn_Riem2.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Riem2];
	fbGeberHandling_VonBahn_Riem2.IwIncGeberZaehler:= 0;
	fbGeberHandling_VonBahn_Riem2.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_VonBahn_Riem2.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_VonBahn_Riem2.IwIstwert:= 0;
	fbGeberHandling_VonBahn_Riem2.IwIncGeberZaehler:= iIncGeberZaehler_Riem2;
	fbGeberHandling_VonBahn_Riem2.IwWegProImpuls:= strIO_GHdshk_Riem2.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_VonBahn_Riem2.IsAnfangBahn:= fbBahn_Riem2.IsAnfangBahn;
fbGeberHandling_VonBahn_Riem2.IsEndeBahn:= fbBahn_Riem2.IsEndeBahn;
fbGeberHandling_VonBahn_Riem2.IsStart:= fbBahn_Riem2.OsPosi_Start_VonBahn;
fbGeberHandling_VonBahn_Riem2.IsIncGeber:=  FALSE;
fbGeberHandling_VonBahn_Riem2.IsRestwertSchreiben:= TRUE;

fbGeberHandling_VonBahn_Riem2.IsIstwertGesetzt:= FALSE;
fbGeberHandling_VonBahn_Riem2.IsImRuecklauf:=
	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf
	OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf;

fbGeberHandling_VonBahn_Riem2.IsPosiAufBahn:= FALSE;
fbGeberHandling_VonBahn_Riem2.IsPosiVonBahn:=
	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobVonBahnPosiVorlauf
	OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
	OR	fbBahn_Riem2.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf
	OR	fbBahn_Riem2.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf;

fbGeberHandling_VonBahn_Riem2.IsPosi_AufDerBahn:=
	NOT fbGeberHandling_VonBahn_Riem2.IsPosiVonBahn;

fbGeberHandling_VonBahn_Riem2.IsTestbetrieb:= bI_Testbetrieb;
fbGeberHandling_VonBahn_Riem2.IwZielPosition:= strIO_GHdshk_Riem2.r_ZielVonBahn;
fbGeberHandling_VonBahn_Riem2 ( IO_IstwertSetzen:= gxNop );


(*------ Position auf der Bahn  ---------------------------------*)
IF	uiI_AxId_Riem2 <> 0
THEN
	fbGeberHandling_PosPlatte_Riem2.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_PosPlatte_Riem2.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Riem2];
	fbGeberHandling_PosPlatte_Riem2.IwIncGeberZaehler:= 0;
	fbGeberHandling_PosPlatte_Riem2.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_PosPlatte_Riem2.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_PosPlatte_Riem2.IwIstwert:= 0;
	fbGeberHandling_PosPlatte_Riem2.IwIncGeberZaehler:= iIncGeberZaehler_Riem2;
	fbGeberHandling_PosPlatte_Riem2.IwWegProImpuls:= strIO_GHdshk_Riem2.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_PosPlatte_Riem2.IsIncGeber:= FALSE;
fbGeberHandling_PosPlatte_Riem2.IsStart:= TRUE;
fbGeberHandling_PosPlatte_Riem2 ( IO_PlattenPos:= strIO_GHdshk_Riem2.str_PlattenPos );


(*------ Kontrolle des Registerimpulses  ---------------------------------*)
fbGeberKontrolle_Riem2.iI_Mode:= 2;
fbGeberKontrolle_Riem2.iI_MaxAbweichung:= strIO_GHdshk_Riem2.str_Bahndaten.iMaxAbweichungSkalierungRegisterimpuls;
fbGeberKontrolle_Riem2.iI_IncGeberZaehler:= iIncGeberZaehler_Riem2;
fbGeberKontrolle_Riem2.lrI_Geschwindigkeit:= ABS(strIO_GHdshk_Riem2.lr_Bahnspeed_Ist);
fbGeberKontrolle_Riem2.rI_WegProImpuls:= strIO_GHdshk_Riem2.str_Bahndaten.rWegProImpuls;
fbGeberKontrolle_Riem2.bI_AntriebLaeuft:= ( strIO_GHdshk_Riem2.b_BahnVor
							OR	strIO_GHdshk_Riem2.b_BahnZurueck )
							AND	ABS(strIO_GHdshk_Riem2.lr_Bahnspeed_Vorgabe) >= 5
							AND	uiI_AxId_Riem2 = 0;

fbGeberKontrolle_Riem2.bI_Testbetrieb:= bI_Testbetrieb;
fbGeberKontrolle_Riem2.bI_IfStreckenzaehler:= FALSE;
fbGeberKontrolle_Riem2.bI_QuittStoerung:=	strIO_GLmHand.bI_QuittStoerung;

fbGeberKontrolle_Riem2.tI_LaufzeitImpuls:= strIO_GHdshk_Riem2.str_BahnZeiten.tBisFehlerRegisterimpuls;
fbGeberKontrolle_Riem2.tI_LaufzeitMessung:= strIO_GHdshk_Riem2.str_BahnZeiten.tMesslaengeSkalierungRegisterimpuls;

fbGeberKontrolle_Riem2();]]></ST>
      </Implementation>
    </Action>
    <Action Name="F_Positionierung_Roll1" Id="{fb856b48-ff16-477b-8c69-d172ae4a4359}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Positionierung																	*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)


(*------ Achse Istwertsetzen  ---------------------------------*)
IF	uiI_AxId_Roll1 <> 0
THEN
	IF	fbBahn_Roll1.IwDoJob_AufBahn = eRolljobKeinJob
		AND	fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobKeinJob
		AND	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobKeinJob
		AND	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobKeinJob
		AND	fbAxIstwert_Roll1.OwOut.eAchsStatus = eStatAchse_BereitFuerJob
		AND NOT strIO_GHdshk_Roll1.b_BahnBelegt
		AND	strIO_TrE.iAnzahlPlatten = 0
		AND	strIO_TrE.asBarcode[1] = ''
		AND NOT bIstwertSetzen_Roll1
		AND ( AxFrNc_fPosIst[uiI_AxId_Roll1] > 50000
			OR	AxFrNc_fPosIst[uiI_AxId_Roll1] < -50000 )
	THEN
		bIstwertSetzen_Roll1:= TRUE;
	END_IF;

	fbAxIstwert_Roll1.AxId:= uiI_AxId_Roll1;
	fbAxIstwert_Roll1.IwResetMode:= 0;		(* Reset Modul *)

	fbAxIstwert_Roll1.IsHand:= bI_Hand;

	fbAxIstwert_Roll1.IsResetNachNotHalt:=
		AxFrNcFehler[uiI_AxId_Roll1]
		AND 	strIO_GLmHand.bI_QuittStoerung;

	fbAxIstwert_Roll1.IsAxFrNc_Auftraglaeuft:= AxFrNcAuftraglaeuft[uiI_AxId_Roll1];
	fbAxIstwert_Roll1.IsAxFrNc_Steht:= AxFrNcSteht[uiI_AxId_Roll1];
	fbAxIstwert_Roll1.IsAxFrNc_Geeicht:= AxFrNcGeeicht[uiI_AxId_Roll1];
	fbAxIstwert_Roll1.IsAxFrNc_Fehler:= AxFrNcFehler[uiI_AxId_Roll1];
	fbAxIstwert_Roll1.IwAxFrNc_nErrorCode:= AxFrNc_nErrorCode[uiI_AxId_Roll1];
	fbAxIstwert_Roll1.IsModuloAchse:= FALSE;
	
	fbAxIstwert_Roll1.IsReset:=
		( bI_FreigabeHandVorZurueck_Roll1
			OR	bI_FreigabeReset )
		AND	strIO_GLmHand.bI_Reset;
	
	IF	bIstwertSetzen_Roll1
		AND NOT fbAxIstwert_Roll1.IsIstwertSetzen
	THEN
		fbAxIstwert_Roll1.IsIstwertSetzen:= TRUE;
		fbAxIstwert_Roll1.IwWertIstwertSetzen:= 0;
	END_IF;
	
	IF	fbAxIstwert_Roll1.IsIstwertSetzen
		AND	fbAxIstwert_Roll1.OwOut.xIstwertGesetzt
	THEN
		fbAxIstwert_Roll1.IsIstwertSetzen:= FALSE;
		bIstwertSetzen_Roll1:= FALSE;
		lrIstwert_Bahn_Roll1:= 0;
	END_IF;


		fbAxIstwert_Roll1();

(*------ Simulation Istwert  ---------------------------------*)

	IF	bI_Testbetrieb
	THEN
		IF	strIO_GHdshk_Roll1.b_BahnVor
		THEN
			lrIstwert_Bahn_Roll1:=
				lrIstwert_Bahn_Roll1
				+ ABS((( strIO_GHdshk_Roll1.lr_Bahnspeed_Vorgabe * 1000) / 60 ) * lrZyklusZeit_SPS );
	
		ELSIF	strIO_GHdshk_Roll1.b_BahnZurueck
		THEN
			lrIstwert_Bahn_Roll1:=
				lrIstwert_Bahn_Roll1
				- ABS((( strIO_GHdshk_Roll1.lr_Bahnspeed_Vorgabe * 1000) / 60 ) * lrZyklusZeit_SPS );
		END_IF;
	
		AxFrNc_fPosIst[uiI_AxId_Roll1]:= LREAL_TO_REAL ( lrIstwert_Bahn_Roll1 );
	END_IF;
END_IF;

IF ( bI_Testbetrieb
	OR	bI_OhneImpulsgeber_Roll1 )
	AND	uiI_AxId_Roll1 = 0
THEN
	fbVirtuellerImpulsgeber_Roll1(
		bI_Start:= strIO_GHdshk_Roll1.b_BahnVor
				OR	strIO_GHdshk_Roll1.b_BahnZurueck,
		lrI_TimeBase:= lrZyklusZeit_SPS,
		lrI_Speed:= ABS(strIO_GHdshk_Roll1.lr_Bahnspeed_Vorgabe),
		lrI_WegProImpuls:= strIO_GHdshk_Roll1.str_Bahndaten.rWegProImpuls,
		IO_Impulse:= iIncGeberZaehler_Roll1 );
END_IF;

(*------ AufBahn Positionierung Bahn  ---------------------------------*)
IF	uiI_AxId_Roll1 <> 0
THEN
	fbGeberHandling_AufBahn_Roll1.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_AufBahn_Roll1.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Roll1];
	fbGeberHandling_AufBahn_Roll1.IwIncGeberZaehler:= 0;
	fbGeberHandling_AufBahn_Roll1.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_AufBahn_Roll1.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_AufBahn_Roll1.IwIstwert:= 0;
	fbGeberHandling_AufBahn_Roll1.IwIncGeberZaehler:= iIncGeberZaehler_Roll1;
	fbGeberHandling_AufBahn_Roll1.IwWegProImpuls:= strIO_GHdshk_Roll1.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_AufBahn_Roll1.IsAnfangBahn:= fbBahn_Roll1.IsAnfangBahn;
fbGeberHandling_AufBahn_Roll1.IsEndeBahn:= fbBahn_Roll1.IsEndeBahn;
fbGeberHandling_AufBahn_Roll1.IsStart:= fbBahn_Roll1.OsPosi_Start_AufBahn;
fbGeberHandling_AufBahn_Roll1.IsIncGeber:=  FALSE;
fbGeberHandling_AufBahn_Roll1.IsRestwertSchreiben:= TRUE;

fbGeberHandling_AufBahn_Roll1.IsIstwertGesetzt:= FALSE;
fbGeberHandling_AufBahn_Roll1.IsImRuecklauf:=
	fbBahn_Roll1.IwDoJob_AufBahn = eRolljobAufBahnPosiRuecklauf
	OR	fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf;

fbGeberHandling_AufBahn_Roll1.IsPosiAufBahn:=
	fbBahn_Roll1.IwDoJob_AufBahn = eRolljobAufBahnPosiVorlauf
	OR	fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf
	OR	fbBahn_Roll1.IwDoJob_AufBahn = eRolljobAufBahnPosiRuecklauf
	OR	fbBahn_Roll1.OwJobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf;

fbGeberHandling_AufBahn_Roll1.IsPosiVonBahn:= FALSE;

fbGeberHandling_AufBahn_Roll1.IsPosi_AufDerBahn:=
	NOT fbGeberHandling_AufBahn_Roll1.IsPosiAufBahn
	AND NOT fbGeberHandling_AufBahn_Roll1.IsPosiVonBahn;

fbGeberHandling_AufBahn_Roll1.IsTestbetrieb:= bI_Testbetrieb;
fbGeberHandling_AufBahn_Roll1.IwZielPosition:= strIO_GHdshk_Roll1.r_ZielAufBahn;
fbGeberHandling_AufBahn_Roll1 ( IO_IstwertSetzen:= gxNop );


(*------ VonBahn Positionierung Bahn  ---------------------------------*)
IF	uiI_AxId_Roll1 <> 0
THEN
	fbGeberHandling_VonBahn_Roll1.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_VonBahn_Roll1.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Roll1];
	fbGeberHandling_VonBahn_Roll1.IwIncGeberZaehler:= 0;
	fbGeberHandling_VonBahn_Roll1.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_VonBahn_Roll1.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_VonBahn_Roll1.IwIstwert:= 0;
	fbGeberHandling_VonBahn_Roll1.IwIncGeberZaehler:= iIncGeberZaehler_Roll1;
	fbGeberHandling_VonBahn_Roll1.IwWegProImpuls:= strIO_GHdshk_Roll1.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_VonBahn_Roll1.IsAnfangBahn:= fbBahn_Roll1.IsAnfangBahn;
fbGeberHandling_VonBahn_Roll1.IsEndeBahn:= fbBahn_Roll1.IsEndeBahn;
fbGeberHandling_VonBahn_Roll1.IsStart:= fbBahn_Roll1.OsPosi_Start_VonBahn;
fbGeberHandling_VonBahn_Roll1.IsIncGeber:=  FALSE;
fbGeberHandling_VonBahn_Roll1.IsRestwertSchreiben:= TRUE;

fbGeberHandling_VonBahn_Roll1.IsIstwertGesetzt:= FALSE;
fbGeberHandling_VonBahn_Roll1.IsImRuecklauf:=
	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf
	OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf;

fbGeberHandling_VonBahn_Roll1.IsPosiAufBahn:= FALSE;
fbGeberHandling_VonBahn_Roll1.IsPosiVonBahn:=
	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobVonBahnPosiVorlauf
	OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiVorlauf
	OR	fbBahn_Roll1.IwDoJob_VonBahn = eRolljobVonBahnPosiRuecklauf
	OR	fbBahn_Roll1.OwJobAktiv_VonBahn = eRolljobVonBahnPosiRuecklauf;

fbGeberHandling_VonBahn_Roll1.IsPosi_AufDerBahn:=
	NOT fbGeberHandling_VonBahn_Roll1.IsPosiVonBahn;

fbGeberHandling_VonBahn_Roll1.IsTestbetrieb:= bI_Testbetrieb;
fbGeberHandling_VonBahn_Roll1.IwZielPosition:= strIO_GHdshk_Roll1.r_ZielVonBahn;
fbGeberHandling_VonBahn_Roll1 ( IO_IstwertSetzen:= gxNop );


(*------ Position auf der Bahn  ---------------------------------*)
IF	uiI_AxId_Roll1 <> 0
THEN
	fbGeberHandling_PosPlatte_Roll1.IwMode:= 1;		(* Achse auswerten *)
	fbGeberHandling_PosPlatte_Roll1.IwIstwert:= AxFrNc_fPosIst[uiI_AxId_Roll1];
	fbGeberHandling_PosPlatte_Roll1.IwIncGeberZaehler:= 0;
	fbGeberHandling_PosPlatte_Roll1.IwWegProImpuls:= 0;
ELSE
	fbGeberHandling_PosPlatte_Roll1.IwMode:= 2;		(* Zähler auswerten *)
	fbGeberHandling_PosPlatte_Roll1.IwIstwert:= 0;
	fbGeberHandling_PosPlatte_Roll1.IwIncGeberZaehler:= iIncGeberZaehler_Roll1;
	fbGeberHandling_PosPlatte_Roll1.IwWegProImpuls:= strIO_GHdshk_Roll1.str_Bahndaten.rWegProImpuls;
END_IF;

fbGeberHandling_PosPlatte_Roll1.IsIncGeber:= FALSE;
fbGeberHandling_PosPlatte_Roll1.IsStart:= TRUE;
fbGeberHandling_PosPlatte_Roll1 ( IO_PlattenPos:= strIO_GHdshk_Roll1.str_PlattenPos );


(*------ Kontrolle des Registerimpulses  ---------------------------------*)
fbGeberKontrolle_Roll1.iI_Mode:= 2;
fbGeberKontrolle_Roll1.iI_MaxAbweichung:= strIO_GHdshk_Roll1.str_Bahndaten.iMaxAbweichungSkalierungRegisterimpuls;
fbGeberKontrolle_Roll1.iI_IncGeberZaehler:= iIncGeberZaehler_Roll1;
fbGeberKontrolle_Roll1.lrI_Geschwindigkeit:= ABS(strIO_GHdshk_Roll1.lr_Bahnspeed_Ist);
fbGeberKontrolle_Roll1.rI_WegProImpuls:= strIO_GHdshk_Roll1.str_Bahndaten.rWegProImpuls;
fbGeberKontrolle_Roll1.bI_AntriebLaeuft:= ( strIO_GHdshk_Roll1.b_BahnVor
							OR	strIO_GHdshk_Roll1.b_BahnZurueck )
							AND	ABS(strIO_GHdshk_Roll1.lr_Bahnspeed_Vorgabe) >= 5
							AND	uiI_AxId_Roll1 = 0;

fbGeberKontrolle_Roll1.bI_Testbetrieb:= bI_Testbetrieb;
fbGeberKontrolle_Roll1.bI_IfStreckenzaehler:= FALSE;
fbGeberKontrolle_Roll1.bI_QuittStoerung:=	strIO_GLmHand.bI_QuittStoerung;

fbGeberKontrolle_Roll1.tI_LaufzeitImpuls:= strIO_GHdshk_Roll1.str_BahnZeiten.tBisFehlerRegisterimpuls;
fbGeberKontrolle_Roll1.tI_LaufzeitMessung:= strIO_GHdshk_Roll1.str_BahnZeiten.tMesslaengeSkalierungRegisterimpuls;

fbGeberKontrolle_Roll1();]]></ST>
      </Implementation>
    </Action>
    <Action Name="G_Protokoll_Riem1" Id="{e83e8443-8baf-4260-a743-54f63d768f5e}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Protokoll																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)


(*
   Proto: Werte 'Fahrt in Grund'
*)
IF	fbBahn_Riem1.xFahrtInGrund
	AND NOT bProto_BahnInGrund_Riem1
THEN
	F_ProtoText4 ( uiI_ProId,
			CONCAT( fbBahn_Riem1.IwBahnName, ' - Fahrt in Grund' ),
			CONCAT( ' / iMode: ', F_BahnInGrund_Text( fbBahn_Riem1.IwBahnMode.iFahrtInGrund )),
			CONCAT( ' / Daten prüfen: ', BOOL_TO_STRING( fbBahn_Riem1.IwBahnMode.xDatenPruefen_NachGrund )),
			'' );

	bProto_BahnInGrund_Riem1:= TRUE;

ELSIF NOT fbBahn_Riem1.xFahrtInGrund
	AND	bProto_BahnInGrund_Riem1
THEN
	bProto_BahnInGrund_Riem1:= FALSE;
END_IF;

(*
   Protokollierung Zustände
*)

IF	iLast_Sket1_Riem1 <> fbBahn_Riem1.SKet1
	OR	iLast_Sket2_Riem1 <> fbBahn_Riem1.SKet2
	OR	bLast_Belegt_Riem1 <> fbBahn_Riem1.IsBelegtVorEndeBahn
	OR	bLast_Anfang_Riem1 <> fbBahn_Riem1.IsAnfangBahn
	OR	bLast_Ende_Riem1 <> fbBahn_Riem1.IsEndeBahn
	OR	bLast_Vorlauf_Riem1 <> fbBahn_Riem1.OsBahnVor
	OR	bLast_Zurueck_Riem1 <> fbBahn_Riem1.OsBahnZurueck
	OR	iLast_Speed_Riem1 <> fbBahn_Riem1.OwBahnSpeed
THEN
	iLast_Sket1_Riem1:= fbBahn_Riem1.SKet1;
	iLast_Sket2_Riem1:= fbBahn_Riem1.SKet2;
	bLast_Belegt_Riem1:= fbBahn_Riem1.IsBelegtVorEndeBahn;
	bLast_Anfang_Riem1:= fbBahn_Riem1.IsAnfangBahn;
	bLast_Ende_Riem1:= fbBahn_Riem1.IsEndeBahn;
	bLast_Vorlauf_Riem1:= fbBahn_Riem1.OsBahnVor;
	bLast_Zurueck_Riem1:= fbBahn_Riem1.OsBahnZurueck;
	iLast_Speed_Riem1:= fbBahn_Riem1.OwBahnSpeed;


	F_ProtoText8( uiI_ProId,
			CONCAT( fbBahn_Riem1.IwBahnName,
				  CONCAT( ' - Stat: ', INT_TO_STRING( strIO_TrE.iJobStatus ))),
			CONCAT( CONCAT( ' / Ske1: ', INT_TO_STRING( iLast_Sket1_Riem1 )),
				  CONCAT( ' / Ske2: ', INT_TO_STRING( iLast_Sket2_Riem1 ))),
			CONCAT( CONCAT( ' / Bel: ', INT_TO_STRING( strIO_TrE.iBelegtStatus )),
				  CONCAT( ' / Ist: ', INT_TO_STRING( strIO_TrE.iAnzahlPlatten ))),
			CONCAT( CONCAT( ' / Anfg: ', BOOL_TO_STRING( bLast_Anfang_Riem1 )),
				  CONCAT( ' / Ende: ', BOOL_TO_STRING( bLast_Ende_Riem1 ))),
			CONCAT( CONCAT( ' / Vor: ', BOOL_TO_STRING( bLast_Vorlauf_Riem1 )),
				  CONCAT( ' / Zur: ', BOOL_TO_STRING( bLast_Zurueck_Riem1 ))),
			CONCAT( CONCAT( ' / Speed: ', INT_TO_STRING( iLast_Speed_Riem1 )),
				  CONCAT( ' / PosPla: ', F_RealToString_2Nach( strIO_GHdshk_Riem1.str_PlattenPos.arPlattenPos[1] ))),
			CONCAT( CONCAT( ' / Auf: ', F_RealToString_2Nach( strIO_GHdshk_Riem1.r_ZielAufBahn )),
				  CONCAT( ' / Von: ', F_RealToString_2Nach( strIO_GHdshk_Riem1.r_ZielVonBahn ))),
			'' );
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="G_Protokoll_Riem2" Id="{69b4c2a0-3d5b-4de4-b905-723afe3e3530}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Protokoll																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)


(*
   Proto: Werte 'Fahrt in Grund'
*)
IF	fbBahn_Riem2.xFahrtInGrund
	AND NOT bProto_BahnInGrund_Riem2
THEN
	F_ProtoText4 ( uiI_ProId,
			CONCAT( fbBahn_Riem2.IwBahnName, ' - Fahrt in Grund' ),
			CONCAT( ' / iMode: ', F_BahnInGrund_Text( fbBahn_Riem2.IwBahnMode.iFahrtInGrund )),
			CONCAT( ' / Daten prüfen: ', BOOL_TO_STRING( fbBahn_Riem2.IwBahnMode.xDatenPruefen_NachGrund )),
			'' );

	bProto_BahnInGrund_Riem2:= TRUE;

ELSIF NOT fbBahn_Riem2.xFahrtInGrund
	AND	bProto_BahnInGrund_Riem2
THEN
	bProto_BahnInGrund_Riem2:= FALSE;
END_IF;

(*
   Protokollierung Zustände
*)

IF	iLast_Sket1_Riem2 <> fbBahn_Riem2.SKet1
	OR	iLast_Sket2_Riem2 <> fbBahn_Riem2.SKet2
	OR	bLast_Belegt_Riem2 <> fbBahn_Riem2.IsBelegtVorEndeBahn
	OR	bLast_Anfang_Riem2 <> fbBahn_Riem2.IsAnfangBahn
	OR	bLast_Ende_Riem2 <> fbBahn_Riem2.IsEndeBahn
	OR	bLast_Vorlauf_Riem2 <> fbBahn_Riem2.OsBahnVor
	OR	bLast_Zurueck_Riem2 <> fbBahn_Riem2.OsBahnZurueck
	OR	iLast_Speed_Riem2 <> fbBahn_Riem2.OwBahnSpeed
THEN
	iLast_Sket1_Riem2:= fbBahn_Riem2.SKet1;
	iLast_Sket2_Riem2:= fbBahn_Riem2.SKet2;
	bLast_Belegt_Riem2:= fbBahn_Riem2.IsBelegtVorEndeBahn;
	bLast_Anfang_Riem2:= fbBahn_Riem2.IsAnfangBahn;
	bLast_Ende_Riem2:= fbBahn_Riem2.IsEndeBahn;
	bLast_Vorlauf_Riem2:= fbBahn_Riem2.OsBahnVor;
	bLast_Zurueck_Riem2:= fbBahn_Riem2.OsBahnZurueck;
	iLast_Speed_Riem2:= fbBahn_Riem2.OwBahnSpeed;


	F_ProtoText8( uiI_ProId,
			CONCAT( fbBahn_Riem2.IwBahnName,
				  CONCAT( ' - Stat: ', INT_TO_STRING( strIO_TrE.iJobStatus ))),
			CONCAT( CONCAT( ' / Ske1: ', INT_TO_STRING( iLast_Sket1_Riem2 )),
				  CONCAT( ' / Ske2: ', INT_TO_STRING( iLast_Sket2_Riem2 ))),
			CONCAT( CONCAT( ' / Bel: ', INT_TO_STRING( strIO_TrE.iBelegtStatus )),
				  CONCAT( ' / Ist: ', INT_TO_STRING( strIO_TrE.iAnzahlPlatten ))),
			CONCAT( CONCAT( ' / Anfg: ', BOOL_TO_STRING( bLast_Anfang_Riem2 )),
				  CONCAT( ' / Ende: ', BOOL_TO_STRING( bLast_Ende_Riem2 ))),
			CONCAT( CONCAT( ' / Vor: ', BOOL_TO_STRING( bLast_Vorlauf_Riem2 )),
				  CONCAT( ' / Zur: ', BOOL_TO_STRING( bLast_Zurueck_Riem2 ))),
			CONCAT( CONCAT( ' / Speed: ', INT_TO_STRING( iLast_Speed_Riem2 )),
				  CONCAT( ' / PosPla: ', F_RealToString_2Nach( strIO_GHdshk_Riem2.str_PlattenPos.arPlattenPos[1] ))),
			CONCAT( CONCAT( ' / Auf: ', F_RealToString_2Nach( strIO_GHdshk_Riem2.r_ZielAufBahn )),
				  CONCAT( ' / Von: ', F_RealToString_2Nach( strIO_GHdshk_Riem2.r_ZielVonBahn ))),
			'' );
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="G_Protokoll_Roll1" Id="{2fcd7de6-9313-485c-ae78-ebf38e59606e}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Protokoll																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)


(*
   Proto: Werte 'Fahrt in Grund'
*)
IF	fbBahn_Roll1.xFahrtInGrund
	AND NOT bProto_BahnInGrund_Roll1
THEN
	F_ProtoText4 ( uiI_ProId,
			CONCAT( fbBahn_Roll1.IwBahnName, ' - Fahrt in Grund' ),
			CONCAT( ' / iMode: ', F_BahnInGrund_Text( fbBahn_Roll1.IwBahnMode.iFahrtInGrund )),
			CONCAT( ' / Daten prüfen: ', BOOL_TO_STRING( fbBahn_Roll1.IwBahnMode.xDatenPruefen_NachGrund )),
			'' );

	bProto_BahnInGrund_Roll1:= TRUE;

ELSIF NOT fbBahn_Roll1.xFahrtInGrund
	AND	bProto_BahnInGrund_Roll1
THEN
	bProto_BahnInGrund_Roll1:= FALSE;
END_IF;

(*
   Protokollierung Zustände
*)

IF	iLast_Sket1_Roll1 <> fbBahn_Roll1.SKet1
	OR	iLast_Sket2_Roll1 <> fbBahn_Roll1.SKet2
	OR	bLast_Belegt_Roll1 <> fbBahn_Roll1.IsBelegtVorEndeBahn
	OR	bLast_Anfang_Roll1 <> fbBahn_Roll1.IsAnfangBahn
	OR	bLast_Ende_Roll1 <> fbBahn_Roll1.IsEndeBahn
	OR	bLast_Vorlauf_Roll1 <> fbBahn_Roll1.OsBahnVor
	OR	bLast_Zurueck_Roll1 <> fbBahn_Roll1.OsBahnZurueck
	OR	iLast_Speed_Roll1 <> fbBahn_Roll1.OwBahnSpeed
THEN
	iLast_Sket1_Roll1:= fbBahn_Roll1.SKet1;
	iLast_Sket2_Roll1:= fbBahn_Roll1.SKet2;
	bLast_Belegt_Roll1:= fbBahn_Roll1.IsBelegtVorEndeBahn;
	bLast_Anfang_Roll1:= fbBahn_Roll1.IsAnfangBahn;
	bLast_Ende_Roll1:= fbBahn_Roll1.IsEndeBahn;
	bLast_Vorlauf_Roll1:= fbBahn_Roll1.OsBahnVor;
	bLast_Zurueck_Roll1:= fbBahn_Roll1.OsBahnZurueck;
	iLast_Speed_Roll1:= fbBahn_Roll1.OwBahnSpeed;


	F_ProtoText8( uiI_ProId,
			CONCAT( fbBahn_Roll1.IwBahnName,
				  CONCAT( ' - Stat: ', INT_TO_STRING( strIO_TrE.iJobStatus ))),
			CONCAT( CONCAT( ' / Ske1: ', INT_TO_STRING( iLast_Sket1_Roll1 )),
				  CONCAT( ' / Ske2: ', INT_TO_STRING( iLast_Sket2_Roll1 ))),
			CONCAT( CONCAT( ' / Bel: ', INT_TO_STRING( strIO_TrE.iBelegtStatus )),
				  CONCAT( ' / Ist: ', INT_TO_STRING( strIO_TrE.iAnzahlPlatten ))),
			CONCAT( CONCAT( ' / Anfg: ', BOOL_TO_STRING( bLast_Anfang_Roll1 )),
				  CONCAT( ' / Ende: ', BOOL_TO_STRING( bLast_Ende_Roll1 ))),
			CONCAT( CONCAT( ' / Vor: ', BOOL_TO_STRING( bLast_Vorlauf_Roll1 )),
				  CONCAT( ' / Zur: ', BOOL_TO_STRING( bLast_Zurueck_Roll1 ))),
			CONCAT( CONCAT( ' / Speed: ', INT_TO_STRING( iLast_Speed_Roll1 )),
				  CONCAT( ' / PosPla: ', F_RealToString_2Nach( strIO_GHdshk_Roll1.str_PlattenPos.arPlattenPos[1] ))),
			CONCAT( CONCAT( ' / Auf: ', F_RealToString_2Nach( strIO_GHdshk_Roll1.r_ZielAufBahn )),
				  CONCAT( ' / Von: ', F_RealToString_2Nach( strIO_GHdshk_Roll1.r_ZielVonBahn ))),
			'' );
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="H_Funktionsauswertung_Riem1" Id="{d37820db-df25-457e-9a48-988286c48e25}">
      <Implementation>
        <ST><![CDATA[(*
-------------------------------------------------------
-------------------------------------------------------

   Inhalt: 		Funtionsauswertung



   Belegtstatus:
	- iSektionFrei
	- iSektionBelegt
	- iBereitFuerLader
	- iSpurFertig
	- iGesperrt

   AufBahn Bereit für Job:
	-  0 = kein AufBahn Job darf aktiv sein
	-  1 = AufBahn Job darf aktiv sein
	-  3 = AufBahn Job 'AnsBahnende' darf aktiv sein
 	-  4 = AufBahn Job 'AnBahnanfang' darf aktiv sein
	- -1 = undefiniert

   VonBahn Bereit für Job:
	-  0 = kein VonBahn Job darf aktiv sein
	-  1 = VonBahn Job darf aktiv sein
	-  2 = Von Bahn Job + 'OsFreigabeAufBahn_BeiVonBahn' darf aktiv sein
	-  3 = Von Bahn Job 'AnsBahnende' darf aktiv sein
 	-  4 = Von Bahn Job 'AnBahnanfang' darf aktiv sein
	- -1 = undefiniert

-------------------------------------------------------
-------------------------------------------------------
*)
(*
-------------------------------------------------------
-------------------------------------------------------
	Funtionsauswertung Belegtstatus
-------------------------------------------------------
-------------------------------------------------------
*)

IF	F_GetBelegtStatus ( uiI_TrEId, iSektionFrei )
	AND NOT F_GetBelegtStatus ( uiI_TrEId, iSektionBelegt )
THEN
	strIO_GHdshk_Riem1.b_SektionFrei:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_SektionFrei:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSektionBelegt )
THEN
	strIO_GHdshk_Riem1.b_SektionBelegt:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_SektionBelegt:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iBereitFuerLader )
THEN
	strIO_GHdshk_Riem1.b_BereitFuerLader:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_BereitFuerLader:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSektionVoll )
THEN
	strIO_GHdshk_Riem1.b_SektionVoll:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_SektionVoll:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSpurFertig )
THEN
	strIO_GHdshk_Riem1.b_SektionFertig:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_SektionFertig:= FALSE;
END_IF;


IF	strIO_TrE.iSperren.0
	AND	strIO_TrE.iSperren.1
THEN
	strIO_GHdshk_Riem1.b_SektionAllgemeinGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_SektionAllgemeinGesperrt:= FALSE;
END_IF;

IF	F_GetBelegtStatus ( uiI_TrEId, iGesperrt )
	OR	strIO_TrE.iSperren.0
	OR	bIstwertSetzen_Riem1
THEN
	strIO_GHdshk_Riem1.b_SektionEinlaufGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_SektionEinlaufGesperrt:= FALSE;
END_IF;

IF	strIO_TrE.iSperren.1
THEN
	strIO_GHdshk_Riem1.b_SektionAuslaufGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Riem1.b_SektionAuslaufGesperrt:= FALSE;
END_IF;

(*
-------------------------------------------------------
-------------------------------------------------------
	Funtionsauswertung AufBahn Bereit für Job
-------------------------------------------------------
-------------------------------------------------------
*)


IF	F_BahnV2_BereitFuerJob ( 0, -1, strIO_GHdshk_Riem1  )		(* 0 = kein AufBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob:= 0;

ELSIF	F_BahnV2_BereitFuerJob ( 1, -1, strIO_GHdshk_Riem1 )		(* 1 = AufBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob:= 1;

ELSIF	F_BahnV2_BereitFuerJob ( 3, -1, strIO_GHdshk_Riem1 )		(* 3 = AufBahn Job 'AnsBahnende' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob:= 3;

ELSIF	F_BahnV2_BereitFuerJob ( 4, -1, strIO_GHdshk_Riem1 )		(* 4 = AufBahn Job 'AnBahnanfang' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob:= 4;
ELSE
	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob:= 99;	(* 99 = undefiniert *)
END_IF

(*
-------------------------------------------------------
-------------------------------------------------------
Funtionsauswertung VonBahn Bereit für Job
-------------------------------------------------------
-------------------------------------------------------
*)


IF	F_BahnV2_BereitFuerJob ( -1, 0, strIO_GHdshk_Riem1 )		(* 0 = kein VonBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob:= 0;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 1, strIO_GHdshk_Riem1 )		(* 1 = VonBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob:= 1;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 2, strIO_GHdshk_Riem1 )		(* 2 = Von Bahn Job + 'OsFreigabeAufBahn_BeiVonBahn' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob:= 2;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 3, strIO_GHdshk_Riem1 )		(* 3 =  Von Bahn Job 'AnsBahnende' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob:= 3;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 4, strIO_GHdshk_Riem1 )		(* 4 =  Von Bahn Job 'AnBahnanfang' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob:= 4;
ELSE
	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob:= 99;	(* 99 = undefiniert *)
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="H_Funktionsauswertung_Riem2" Id="{42220141-85fe-4200-b30e-ec617e9e1784}">
      <Implementation>
        <ST><![CDATA[(*
-------------------------------------------------------
-------------------------------------------------------

   Inhalt: 		Funtionsauswertung



   Belegtstatus:
	- iSektionFrei
	- iSektionBelegt
	- iBereitFuerLader
	- iSpurFertig
	- iGesperrt

   AufBahn Bereit für Job:
	-  0 = kein AufBahn Job darf aktiv sein
	-  1 = AufBahn Job darf aktiv sein
	-  3 = AufBahn Job 'AnsBahnende' darf aktiv sein
 	-  4 = AufBahn Job 'AnBahnanfang' darf aktiv sein
	- -1 = undefiniert

   VonBahn Bereit für Job:
	-  0 = kein VonBahn Job darf aktiv sein
	-  1 = VonBahn Job darf aktiv sein
	-  2 = Von Bahn Job + 'OsFreigabeAufBahn_BeiVonBahn' darf aktiv sein
	-  3 = Von Bahn Job 'AnsBahnende' darf aktiv sein
 	-  4 = Von Bahn Job 'AnBahnanfang' darf aktiv sein
	- -1 = undefiniert

-------------------------------------------------------
-------------------------------------------------------
*)
(*
-------------------------------------------------------
-------------------------------------------------------
	Funtionsauswertung Belegtstatus
-------------------------------------------------------
-------------------------------------------------------
*)

IF	F_GetBelegtStatus ( uiI_TrEId, iSektionFrei )
	AND NOT F_GetBelegtStatus ( uiI_TrEId, iSektionBelegt )
THEN
	strIO_GHdshk_Riem2.b_SektionFrei:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_SektionFrei:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSektionBelegt )
THEN
	strIO_GHdshk_Riem2.b_SektionBelegt:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_SektionBelegt:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iBereitFuerLader )
THEN
	strIO_GHdshk_Riem2.b_BereitFuerLader:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_BereitFuerLader:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSektionVoll )
THEN
	strIO_GHdshk_Riem2.b_SektionVoll:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_SektionVoll:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSpurFertig )
THEN
	strIO_GHdshk_Riem2.b_SektionFertig:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_SektionFertig:= FALSE;
END_IF;


IF	strIO_TrE.iSperren.0
	AND	strIO_TrE.iSperren.1
THEN
	strIO_GHdshk_Riem2.b_SektionAllgemeinGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_SektionAllgemeinGesperrt:= FALSE;
END_IF;

IF	F_GetBelegtStatus ( uiI_TrEId, iGesperrt )
	OR	strIO_TrE.iSperren.0
	OR	bIstwertSetzen_Riem2
THEN
	strIO_GHdshk_Riem2.b_SektionEinlaufGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_SektionEinlaufGesperrt:= FALSE;
END_IF;

IF	strIO_TrE.iSperren.1
THEN
	strIO_GHdshk_Riem2.b_SektionAuslaufGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Riem2.b_SektionAuslaufGesperrt:= FALSE;
END_IF;

(*
-------------------------------------------------------
-------------------------------------------------------
	Funtionsauswertung AufBahn Bereit für Job
-------------------------------------------------------
-------------------------------------------------------
*)


IF	F_BahnV2_BereitFuerJob ( 0, -1, strIO_GHdshk_Riem2  )		(* 0 = kein AufBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob:= 0;

ELSIF	F_BahnV2_BereitFuerJob ( 1, -1, strIO_GHdshk_Riem2 )		(* 1 = AufBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob:= 1;

ELSIF	F_BahnV2_BereitFuerJob ( 3, -1, strIO_GHdshk_Riem2 )		(* 3 = AufBahn Job 'AnsBahnende' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob:= 3;

ELSIF	F_BahnV2_BereitFuerJob ( 4, -1, strIO_GHdshk_Riem2 )		(* 4 = AufBahn Job 'AnBahnanfang' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob:= 4;
ELSE
	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob:= 99;	(* 99 = undefiniert *)
END_IF

(*
-------------------------------------------------------
-------------------------------------------------------
Funtionsauswertung VonBahn Bereit für Job
-------------------------------------------------------
-------------------------------------------------------
*)


IF	F_BahnV2_BereitFuerJob ( -1, 0, strIO_GHdshk_Riem2 )		(* 0 = kein VonBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob:= 0;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 1, strIO_GHdshk_Riem2 )		(* 1 = VonBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob:= 1;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 2, strIO_GHdshk_Riem2 )		(* 2 = Von Bahn Job + 'OsFreigabeAufBahn_BeiVonBahn' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob:= 2;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 3, strIO_GHdshk_Riem2 )		(* 3 =  Von Bahn Job 'AnsBahnende' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob:= 3;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 4, strIO_GHdshk_Riem2 )		(* 4 =  Von Bahn Job 'AnBahnanfang' darf aktiv sein *)
THEN
	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob:= 4;
ELSE
	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob:= 99;	(* 99 = undefiniert *)
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="H_Funktionsauswertung_Roll1" Id="{bcab9cc0-1d45-4734-af7c-b2071f3678a8}">
      <Implementation>
        <ST><![CDATA[(*
-------------------------------------------------------
-------------------------------------------------------

   Inhalt: 		Funtionsauswertung



   Belegtstatus:
	- iSektionFrei
	- iSektionBelegt
	- iBereitFuerLader
	- iSpurFertig
	- iGesperrt

   AufBahn Bereit für Job:
	-  0 = kein AufBahn Job darf aktiv sein
	-  1 = AufBahn Job darf aktiv sein
	-  3 = AufBahn Job 'AnsBahnende' darf aktiv sein
 	-  4 = AufBahn Job 'AnBahnanfang' darf aktiv sein
	- -1 = undefiniert

   VonBahn Bereit für Job:
	-  0 = kein VonBahn Job darf aktiv sein
	-  1 = VonBahn Job darf aktiv sein
	-  2 = Von Bahn Job + 'OsFreigabeAufBahn_BeiVonBahn' darf aktiv sein
	-  3 = Von Bahn Job 'AnsBahnende' darf aktiv sein
 	-  4 = Von Bahn Job 'AnBahnanfang' darf aktiv sein
	- -1 = undefiniert

-------------------------------------------------------
-------------------------------------------------------
*)
(*
-------------------------------------------------------
-------------------------------------------------------
	Funtionsauswertung Belegtstatus
-------------------------------------------------------
-------------------------------------------------------
*)

IF	F_GetBelegtStatus ( uiI_TrEId, iSektionFrei )
	AND NOT F_GetBelegtStatus ( uiI_TrEId, iSektionBelegt )
THEN
	strIO_GHdshk_Roll1.b_SektionFrei:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_SektionFrei:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSektionBelegt )
THEN
	strIO_GHdshk_Roll1.b_SektionBelegt:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_SektionBelegt:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iBereitFuerLader )
THEN
	strIO_GHdshk_Roll1.b_BereitFuerLader:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_BereitFuerLader:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSektionVoll )
THEN
	strIO_GHdshk_Roll1.b_SektionVoll:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_SektionVoll:= FALSE;
END_IF;


IF	F_GetBelegtStatus ( uiI_TrEId, iSpurFertig )
THEN
	strIO_GHdshk_Roll1.b_SektionFertig:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_SektionFertig:= FALSE;
END_IF;


IF	strIO_TrE.iSperren.0
	AND	strIO_TrE.iSperren.1
THEN
	strIO_GHdshk_Roll1.b_SektionAllgemeinGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_SektionAllgemeinGesperrt:= FALSE;
END_IF;

IF	F_GetBelegtStatus ( uiI_TrEId, iGesperrt )
	OR	strIO_TrE.iSperren.0
	OR	bIstwertSetzen_Roll1
THEN
	strIO_GHdshk_Roll1.b_SektionEinlaufGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_SektionEinlaufGesperrt:= FALSE;
END_IF;

IF	strIO_TrE.iSperren.1
THEN
	strIO_GHdshk_Roll1.b_SektionAuslaufGesperrt:= TRUE;
ELSE
	strIO_GHdshk_Roll1.b_SektionAuslaufGesperrt:= FALSE;
END_IF;

(*
-------------------------------------------------------
-------------------------------------------------------
	Funtionsauswertung AufBahn Bereit für Job
-------------------------------------------------------
-------------------------------------------------------
*)


IF	F_BahnV2_BereitFuerJob ( 0, -1, strIO_GHdshk_Roll1  )		(* 0 = kein AufBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob:= 0;

ELSIF	F_BahnV2_BereitFuerJob ( 1, -1, strIO_GHdshk_Roll1 )		(* 1 = AufBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob:= 1;

ELSIF	F_BahnV2_BereitFuerJob ( 3, -1, strIO_GHdshk_Roll1 )		(* 3 = AufBahn Job 'AnsBahnende' darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob:= 3;

ELSIF	F_BahnV2_BereitFuerJob ( 4, -1, strIO_GHdshk_Roll1 )		(* 4 = AufBahn Job 'AnBahnanfang' darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob:= 4;
ELSE
	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob:= 99;	(* 99 = undefiniert *)
END_IF

(*
-------------------------------------------------------
-------------------------------------------------------
Funtionsauswertung VonBahn Bereit für Job
-------------------------------------------------------
-------------------------------------------------------
*)


IF	F_BahnV2_BereitFuerJob ( -1, 0, strIO_GHdshk_Roll1 )		(* 0 = kein VonBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob:= 0;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 1, strIO_GHdshk_Roll1 )		(* 1 = VonBahn Job darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob:= 1;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 2, strIO_GHdshk_Roll1 )		(* 2 = Von Bahn Job + 'OsFreigabeAufBahn_BeiVonBahn' darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob:= 2;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 3, strIO_GHdshk_Roll1 )		(* 3 =  Von Bahn Job 'AnsBahnende' darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob:= 3;

ELSIF	F_BahnV2_BereitFuerJob ( -1, 4, strIO_GHdshk_Roll1 )		(* 4 =  Von Bahn Job 'AnBahnanfang' darf aktiv sein *)
THEN
	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob:= 4;

ELSE
	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob:= 99;	(* 99 = undefiniert *)
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="H_Funktionsauswertung_Verriegelung" Id="{11f1d799-06a3-48cc-9d1a-319ca90c7bbf}">
      <Implementation>
        <ST><![CDATA[(*
-------------------------------------------------------
-------------------------------------------------------

   Inhalt: 		Funtionsauswertung Verriegelung


   Sind in einer Sektion die Rollen aktiv,
   werden die Riemen auf nicht bereit gesetzt und andersherum

-------------------------------------------------------
-------------------------------------------------------
*)


IF 	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob <> 0
	OR	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob <> 0
THEN
	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob:= 99;
	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob:= 99;
	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob:= 99;
	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob:= 99;

ELSIF strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob <> 0
	OR	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob <> 0
	OR	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob <> 0
	OR	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob <> 0
THEN
	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob:= 99;
	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob:= 99;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="I_TrEstati_Diagnose" Id="{64a32da4-2f26-47bc-9dd0-a91ba21b8649}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                 Belegtstatus, Aktivstatus, Diagnose Auf- und Von- Bahn										*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

strIO_TrE.iBelegtStatus:= F_SetClearBelegtStatus ( uiI_TrEId,	iBereitFuerLader,		( strIO_GHdshk_Roll1.b_BahnBelegt
															OR	strIO_GHdshk_Riem1.b_BahnBelegt
															OR	strIO_GHdshk_Riem2.b_BahnBelegt )
															AND	strIO_GHdshk_Roll1.b_BahnSteht
															AND	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob = 0
															AND	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob = 0
															AND	strIO_GHdshk_Riem1.b_BahnSteht
															AND	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob = 0
															AND	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob = 0
															AND	strIO_GHdshk_Riem2.b_BahnSteht
															AND	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob = 0
															AND	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob = 0 );
strIO_TrE.iBelegtStatus:= F_SetClearBelegtStatus ( uiI_TrEId,	iSektionBelegt,		strIO_GHdshk_Roll1.b_BahnBelegt
															OR	strIO_GHdshk_Riem1.b_BahnBelegt
															OR	strIO_GHdshk_Riem2.b_BahnBelegt );
strIO_TrE.iBelegtStatus:= F_SetClearBelegtStatus ( uiI_TrEId,	iFehlerDatenAbgleich,	fbBahn_Roll1.OsFehlerDatenAbgleich
															OR	fbBahn_Riem1.OsFehlerDatenAbgleich
															OR	fbBahn_Riem2.OsFehlerDatenAbgleich );

IF	strIO_GHdshk_Roll1.str_BahnStatus = iStoerung
	OR	strIO_GHdshk_Riem1.str_BahnStatus = iStoerung
	OR	strIO_GHdshk_Riem2.str_BahnStatus = iStoerung
THEN
	strIO_TrE.iAktivStatus:= iStoerung;

ELSIF	strIO_GHdshk_Roll1.str_BahnStatus = iFahrtGrund
	OR	strIO_GHdshk_Riem1.str_BahnStatus = iFahrtGrund
	OR	strIO_GHdshk_Riem2.str_BahnStatus = iFahrtGrund
THEN
	strIO_TrE.iAktivStatus:= iFahrtGrund;

ELSIF	strIO_GHdshk_Roll1.str_BahnStatus = iHand
	OR	strIO_GHdshk_Riem1.str_BahnStatus = iHand
	OR	strIO_GHdshk_Riem2.str_BahnStatus = iHand
THEN
	strIO_TrE.iAktivStatus:= iHand;

ELSIF	strIO_GHdshk_Roll1.str_BahnStatus = iAutomatikAktivJob
	OR	strIO_GHdshk_Riem1.str_BahnStatus = iAutomatikAktivJob
	OR	strIO_GHdshk_Riem2.str_BahnStatus = iAutomatikAktivJob
THEN
	strIO_TrE.iAktivStatus:= iAutomatikAktivJob;

ELSIF	strIO_GHdshk_Roll1.str_BahnStatus = iAutomatikBereitJob
	OR	strIO_GHdshk_Riem1.str_BahnStatus = iAutomatikBereitJob
	OR	strIO_GHdshk_Riem2.str_BahnStatus = iAutomatikBereitJob
THEN
	strIO_TrE.iAktivStatus:= iAutomatikBereitJob;

ELSE
	strIO_TrE.iAktivStatus:= iUnbekannt;
END_IF;


(*----------------------------------------------------*)
(* Bahn: Vollkennung aufheben, wenn Bahn leer		*)
(*----------------------------------------------------*)
IF	( strIO_GHdshk_Roll1.b_SektionVoll
		OR	strIO_GHdshk_Riem1.b_SektionVoll
		OR	strIO_GHdshk_Riem2.b_SektionVoll )
	AND NOT strIO_GHdshk_Roll1.b_BahnBelegt
	AND NOT fbBahn_Roll1.IsMitteBahn
	AND NOT strIO_GHdshk_Riem1.b_BahnBelegt
	AND NOT fbBahn_Riem1.IsMitteBahn
	AND NOT strIO_GHdshk_Riem2.b_BahnBelegt
	AND NOT fbBahn_Riem2.IsMitteBahn
	AND	strIO_TrE.iAnzahlPlatten = 0
	AND	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob = 0
	AND	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob = 0
	AND	fbBahn_Roll1.OwBahnStatus <> iStoerung
	AND	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob = 0
	AND	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob = 0
	AND	fbBahn_Riem1.OwBahnStatus <> iStoerung
	AND	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob = 0
	AND	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob = 0
	AND	fbBahn_Riem2.OwBahnStatus <> iStoerung
	AND	bI_Automatik
THEN
	strIO_TrE.iBelegtStatus:= F_SetClearBelegtStatus( uiI_TrEId, iSektionVoll, FALSE );
END_IF;

(*----------------------------------------------------*)
(* Bahn: Gesperrtkennung aufheben, wenn Bahn leer	*)
(*----------------------------------------------------*)
IF	F_GetBelegtStatus ( uiI_TrEId, iGesperrt )
	AND NOT strIO_GHdshk_Roll1.b_SektionVoll
	AND NOT strIO_GHdshk_Roll1.b_BahnBelegt
	AND NOT fbBahn_Roll1.IsMitteBahn
	AND NOT strIO_GHdshk_Riem1.b_SektionVoll
	AND NOT strIO_GHdshk_Riem1.b_BahnBelegt
	AND NOT fbBahn_Riem1.IsMitteBahn
	AND NOT strIO_GHdshk_Riem2.b_SektionVoll
	AND NOT strIO_GHdshk_Riem2.b_BahnBelegt
	AND NOT fbBahn_Riem2.IsMitteBahn
	AND	strIO_TrE.iAnzahlPlatten = 0
	AND	strIO_GHdshk_Roll1.i_BahnV2_AufBahn_BereitFuerJob = 0
	AND	strIO_GHdshk_Roll1.i_BahnV2_VonBahn_BereitFuerJob = 0
	AND	fbBahn_Roll1.OwBahnStatus <> iStoerung
	AND	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob = 0
	AND	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob = 0
	AND	fbBahn_Riem1.OwBahnStatus <> iStoerung
	AND	strIO_GHdshk_Riem2.i_BahnV2_AufBahn_BereitFuerJob = 0
	AND	strIO_GHdshk_Riem2.i_BahnV2_VonBahn_BereitFuerJob = 0
	AND	fbBahn_Riem2.OwBahnStatus <> iStoerung
	AND	bI_Automatik
THEN
	strIO_TrE.iBelegtStatus:= F_SetClearBelegtStatus( uiI_TrEId, iGesperrt, FALSE );
END_IF;


(* Die globale Struktur für die Leuchtmelde Handtasten beschreiben *)

IF	bI_Hand
	AND bI_FreigabeHandVorZurueck_Roll1
THEN
	IF	fbBahn_Roll1.IsBahnIstAufFoerderhoehe
		AND NOT bI_VorZurueckInversHand
		OR 	bI_BahnDarfZurueckHand_Roll1
			AND	fbBahn_Roll1.IsBahnIstAufFoerderhoehe
			AND	bI_VorZurueckInversHand
	THEN
		strIO_GLmHand.bQ_Vor:= TRUE;
	END_IF;

	IF	fbBahn_Roll1.IsBahnIstAufFoerderhoehe
		AND	bI_VorZurueckInversHand
		OR 	bI_BahnDarfZurueckHand_Roll1
			AND	fbBahn_Roll1.IsBahnIstAufFoerderhoehe
			AND NOT bI_VorZurueckInversHand
	THEN
		strIO_GLmHand.bQ_Zurueck:= TRUE;
	END_IF;
END_IF;

IF	bI_Hand
	AND bI_FreigabeHandVorZurueck_Riem1
THEN
	IF	fbBahn_Riem1.IsBahnIstAufFoerderhoehe
			AND NOT bI_VorZurueckInversHand
		OR	bI_BahnDarfZurueckHand_Riem1
			AND	fbBahn_Riem1.IsBahnIstAufFoerderhoehe
			AND	bI_VorZurueckInversHand
	THEN
		strIO_GLmHand.bQ_Vor:= TRUE;
	END_IF;

	IF	fbBahn_Riem1.IsBahnIstAufFoerderhoehe
			AND bI_VorZurueckInversHand
		OR	bI_BahnDarfZurueckHand_Riem1
			AND	fbBahn_Riem1.IsBahnIstAufFoerderhoehe
			AND NOT bI_VorZurueckInversHand
	THEN
		strIO_GLmHand.bQ_Zurueck:= TRUE;
	END_IF;
END_IF;

IF	bI_Hand
	AND bI_FreigabeHandVorZurueck_Riem2
THEN
	IF	fbBahn_Riem2.IsBahnIstAufFoerderhoehe
			AND NOT bI_VorZurueckInversHand
		OR	bI_BahnDarfZurueckHand_Riem2
			AND	fbBahn_Riem2.IsBahnIstAufFoerderhoehe
			AND	bI_VorZurueckInversHand
	THEN
		strIO_GLmHand.bQ_Vor:= TRUE;
	END_IF;

	IF	fbBahn_Riem2.IsBahnIstAufFoerderhoehe
			AND bI_VorZurueckInversHand
		OR	bI_BahnDarfZurueckHand_Riem2
			AND	fbBahn_Riem2.IsBahnIstAufFoerderhoehe
			AND NOT bI_VorZurueckInversHand
	THEN
		strIO_GLmHand.bQ_Zurueck:= TRUE;
	END_IF;
END_IF;

IF	bI_Hand
	AND ( bI_FreigabeHandHebenSenkenSek1
		OR	bI_FreigabeHandHebenSenkenSek2 )
THEN
	IF NOT fbBahn_Riem1.IsBahnIstAufFoerderhoehe
		AND	bI_FreigabeHandHebenSenkenSek1
		AND NOT bI_HebenSenkenInvers
		OR	NOT fbBahn_Riem1.IsBahnIstAufFoerderhoehe
			AND	bI_FreigabeHandHebenSenkenSek1
			AND NOT bI_HebenSenkenInvers
		OR NOT fbBahn_Roll1.IsBahnIstAufFoerderhoehe
			AND 	bI_HebenSenkenInvers
	THEN
		strIO_GLmHand.bQ_Heben:= TRUE;
	END_IF;

	IF NOT fbBahn_Roll1.IsBahnIstAufFoerderhoehe
		AND NOT bI_HebenSenkenInvers
		OR NOT fbBahn_Riem1.IsBahnIstAufFoerderhoehe
			AND	bI_FreigabeHandHebenSenkenSek1
			AND 	bI_HebenSenkenInvers
		OR NOT fbBahn_Riem2.IsBahnIstAufFoerderhoehe
			AND	bI_FreigabeHandHebenSenkenSek2
			AND 	bI_HebenSenkenInvers
	THEN
		strIO_GLmHand.bQ_Senken:= TRUE;
	END_IF;
END_IF;

IF	bI_Hand
	AND	bI_FreigabeReset
	AND ( strIO_GHdshk_Roll1.i_AblaufStatus_AufBahn <> 0
		OR	strIO_GHdshk_Roll1.i_AblaufStatus_VonBahn <> 0
		OR	strIO_GHdshk_Riem1.i_AblaufStatus_AufBahn <> 0
		OR	strIO_GHdshk_Riem1.i_AblaufStatus_VonBahn <> 0
		OR	strIO_GHdshk_Riem2.i_AblaufStatus_AufBahn <> 0
		OR	strIO_GHdshk_Riem2.i_AblaufStatus_VonBahn <> 0 )
THEN
	strIO_GLmHand.bQ_Reset:= TRUE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Y_Struktur_Riem1" Id="{1f3f4e8f-84bf-4e6f-80a0-3f7061275725}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Struktur																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
strIO_GHdshk_Riem1.b_ExterneBahn						:= FALSE;
strIO_GHdshk_Riem1.b_LiAnfang							:= fbEntprellenAnfang_Riem1.OsSensor;
strIO_GHdshk_Riem1.b_SwAnfang							:= bSwAnfang_Riem1;
strIO_GHdshk_Riem1.b_LiVorAnfang						:= fbEntprellenVorAnfang_Riem1.OsSensor;
strIO_GHdshk_Riem1.b_SwVorAnfang						:= bSwVorAnfang_Riem1;
strIO_GHdshk_Riem1.b_LiEnde							:= fbEntprellenEnde_Riem1.OsSensor;
strIO_GHdshk_Riem1.b_SwEnde							:= bSwEnde_Riem1;
strIO_GHdshk_Riem1.b_LiVorEnde						:= fbEntprellenVorEnde_Riem1.OsSensor;
strIO_GHdshk_Riem1.b_SwVorEnde						:= bSwVorEnde_Riem1;
strIO_GHdshk_Riem1.b_LiBelegtkontrolle					:= fbEntprellenBelegtkontrolle_Riem1.OsSensor;
strIO_GHdshk_Riem1.b_BahnIstAufFoerderhoehe				:= fbBahn_Riem1.IsBahnIstAufFoerderhoehe;
strIO_GHdshk_Riem1.b_BahnVor							:= fbRampe_Riem1.bQ_MovePos;
strIO_GHdshk_Riem1.b_BahnZurueck						:= fbRampe_Riem1.bQ_MoveNeg;
strIO_GHdshk_Riem1.b_BahnSteht						:= fbRampe_Riem1.bQ_MoveNot;
strIO_GHdshk_Riem1.b_FreimeldungAnNachSektion				:= fbBahn_Riem1.OsFreimeldungAnNachSektion
												AND ( strIO_GHdshk_Riem1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnRuecklauf
													OR	strIO_GHdshk_Riem1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnPosiRuecklauf
													OR	strIO_GHdshk_Riem1_Nachf.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem1_Nachf.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem1_Nachf.b_ExterneBahn );
strIO_GHdshk_Riem1.b_FreimeldungAnVorSektion				:= fbBahn_Riem1.OsFreimeldungAnVorSektion
												AND ( strIO_GHdshk_Riem1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnVorlauf
													OR	strIO_GHdshk_Riem1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnPosiVorlauf
													OR	strIO_GHdshk_Riem1_Vorg.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem1_Vorg.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem1_Vorg.b_ExterneBahn );
strIO_GHdshk_Riem1.b_VerstandenPlatteAbgelegt				:= fbBahn_Riem1.OsVerstandenLaderPlatteAbgelegt;
strIO_GHdshk_Riem1.b_VerstandenPlatteGeholt				:= fbBahn_Riem1.OsVerstandenLaderPlatteGeholt;
strIO_GHdshk_Riem1.i_AblaufStatus_AufBahn					:= fbBahn_Riem1.OwAblaufStatus_AufBahn;
strIO_GHdshk_Riem1.i_AblaufStatus_VonBahn					:= fbBahn_Riem1.OwAblaufStatus_VonBahn;
strIO_GHdshk_Riem1.str_BahnStatus						:= fbBahn_Riem1.OwBahnStatus;
strIO_GHdshk_Riem1.str_JobAktiv_AufBahn					:= fbBahn_Riem1.OwJobAktiv_AufBahn;
strIO_GHdshk_Riem1.str_JobAktiv_VonBahn					:= fbBahn_Riem1.OwJobAktiv_VonBahn;
strIO_GHdshk_Riem1.b_MBahnBelegt_KeineDaten				:= fbBahn_Riem1.OsMBahnBelegt_KeineDaten;
strIO_GHdshk_Riem1.b_MBahnFrei_Daten					:= fbBahn_Riem1.OsMBahnFrei_Daten;
strIO_GHdshk_Riem1.b_MBahnNichtAufFoerderhoehe				:= fbBahn_Riem1.OsMBahnNichtAufFoerderhoehe;
strIO_GHdshk_Riem1.b_MMaxLaufzeit_AufBahn					:= fbBahn_Riem1.OsMMaxLaufzeit_AufBahn;
strIO_GHdshk_Riem1.b_MMaxLaufzeit_VonBahn					:= fbBahn_Riem1.OsMMaxLaufzeit_VonBahn;
strIO_GHdshk_Riem1.b_MStoerungAntrieb					:= fbBahn_Riem1.OsMStoerungAntrieb;
strIO_GHdshk_Riem1.b_MKeineFreigabe_FahrtInGrund			:= fbBahn_Riem1.OsMKeineFreigabe_FahrtInGrund;
strIO_GHdshk_Riem1.b_MFehlerRegisterimpuls				:= fbGeberKontrolle_Riem1.bQ_FehlerGeber;
strIO_GHdshk_Riem1.b_MFehlerSkalierung					:= fbGeberKontrolle_Riem1.bQ_FehlerSkalierung;

strIO_GHdshk_Riem1.b_GeberHandling_AufBahn_Aktiv			:= fbGeberHandling_AufBahn_Riem1.OsAktiv;
strIO_GHdshk_Riem1.b_GeberHandling_AufBahn_Fertig			:= fbGeberHandling_AufBahn_Riem1.OsFertig;
strIO_GHdshk_Riem1.r_PosiRestwert_AufBahn					:= fbGeberHandling_AufBahn_Riem1.OwPosiRestWert;

strIO_GHdshk_Riem1.b_GeberHandling_VonBahn_Aktiv			:= fbGeberHandling_VonBahn_Riem1.OsAktiv;
strIO_GHdshk_Riem1.b_GeberHandling_VonBahn_Fertig			:= fbGeberHandling_VonBahn_Riem1.OsFertig;
strIO_GHdshk_Riem1.r_PosiRestwert_VonBahn					:= fbGeberHandling_VonBahn_Riem1.OwPosiRestWert;

IF	fbRampe_Riem1.bI_Couple
THEN
	strIO_GHdshk_Riem1.lr_Bahnspeed_Soll				:= fbRampe_Riem1.lrI_CoupleVelocity;
ELSE
	strIO_GHdshk_Riem1.lr_Bahnspeed_Soll				:= fbRampe_Riem1.lrI_Velocity;
END_IF;

strIO_GHdshk_Riem1.lr_Bahnspeed_Vorgabe					:= fbRampe_Riem1.lrQ_ActVelocity;

IF	( strIO_GHdshk_Riem1.b_LiAnfang
	AND	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn <> eRolljobAufBahnVorlauf
	AND	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn <> eRolljobAufBahnPosiVorlauf
	AND	strIO_GHdshk_Riem1.b_BahnVor
	OR	strIO_GHdshk_Riem1.b_LiEnde
		AND	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn <> eRolljobAufBahnRuecklauf
		AND	strIO_GHdshk_Riem1.str_JobAktiv_AufBahn <> eRolljobAufBahnPosiRuecklauf
		AND	strIO_GHdshk_Riem1.b_BahnZurueck )
	AND NOT strIO_GHdshk_Riem1.b_MTeilNichtFreigegeben
	AND NOT strIO_GLmHand.bI_QuittStoerung
	AND	bI_Automatik
	AND	bI_MitUeberwachungTeilNichtFreigegeben
THEN
	strIO_GHdshk_Riem1.b_MTeilNichtFreigegeben:= TRUE;

ELSIF	strIO_GLmHand.bI_QuittStoerung
THEN
	strIO_GHdshk_Riem1.b_MTeilNichtFreigegeben:= FALSE;
END_IF;

IF NOT strIO_GHdshk_Riem2.b_SektionenKoppelnInX				(* wenn Riem2 einfördert + andere Bahn nur 1 Sektion + Riem1 nix tut, dann die Freigaben von Riem2 in Riem1 nehmen *)
	AND NOT strIO_GHdshk_Riem2.b_SektionenKoppelnInY
	AND (( strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnPosiVorlauf
		OR	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnVorlauf )
		AND	bI_VorgRiemHatNurEineSpur
		OR ( strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnPosiRuecklauf
			OR	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn = eRolljobAufBahnRuecklauf )
			AND	bI_NachfRiemHatNurEineSpur )
	AND	strIO_GHdshk_Riem1.i_BahnV2_AufBahn_BereitFuerJob = 0
	AND	strIO_GHdshk_Riem1.i_BahnV2_VonBahn_BereitFuerJob = 0
	AND	bI_Automatik
THEN
	strIO_GHdshk_Riem1.b_FreimeldungAnNachSektion			:= fbBahn_Riem2.OsFreimeldungAnNachSektion
												AND ( strIO_GHdshk_Riem1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnRuecklauf
													OR	strIO_GHdshk_Riem1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnPosiRuecklauf
													OR	strIO_GHdshk_Riem1_Nachf.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem1_Nachf.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem1_Nachf.b_ExterneBahn
													OR	bI_NachfRiemHatNurEineSpur );
	strIO_GHdshk_Riem1.b_FreimeldungAnVorSektion			:= fbBahn_Riem2.OsFreimeldungAnVorSektion
												AND ( strIO_GHdshk_Riem1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnVorlauf
													OR	strIO_GHdshk_Riem1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnPosiVorlauf
													OR	strIO_GHdshk_Riem1_Vorg.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem1_Vorg.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem1_Vorg.b_ExterneBahn
													OR	bI_VorgRiemHatNurEineSpur );

	IF	fbRampe_Riem2.bI_Couple
	THEN
		strIO_GHdshk_Riem1.lr_Bahnspeed_Soll			:= fbRampe_Riem2.lrI_CoupleVelocity;
	ELSE
		strIO_GHdshk_Riem1.lr_Bahnspeed_Soll			:= fbRampe_Riem2.lrI_Velocity;
	END_IF;

	strIO_GHdshk_Riem1.lr_Bahnspeed_Vorgabe				:= fbRampe_Riem2.lrQ_ActVelocity;
ELSE
	strIO_GHdshk_Riem1.b_FreimeldungAnNachSektion			:= fbBahn_Riem1.OsFreimeldungAnNachSektion
												AND ( strIO_GHdshk_Riem1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnRuecklauf
													OR	strIO_GHdshk_Riem1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnPosiRuecklauf
													OR	strIO_GHdshk_Riem1_Nachf.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem1_Nachf.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem1_Nachf.b_ExterneBahn );
	strIO_GHdshk_Riem1.b_FreimeldungAnVorSektion			:= fbBahn_Riem1.OsFreimeldungAnVorSektion
												AND ( strIO_GHdshk_Riem1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnVorlauf
													OR	strIO_GHdshk_Riem1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnPosiVorlauf
													OR	strIO_GHdshk_Riem1_Vorg.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem1_Vorg.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem1_Vorg.b_ExterneBahn );

	IF	fbRampe_Riem1.bI_Couple
	THEN
		strIO_GHdshk_Riem1.lr_Bahnspeed_Soll			:= fbRampe_Riem1.lrI_CoupleVelocity;
	ELSE
		strIO_GHdshk_Riem1.lr_Bahnspeed_Soll			:= fbRampe_Riem1.lrI_Velocity;
	END_IF;

	strIO_GHdshk_Riem1.lr_Bahnspeed_Vorgabe				:= fbRampe_Riem1.lrQ_ActVelocity;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Y_Struktur_Riem2" Id="{bd52e485-01b8-4021-9a21-1910782f4b44}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Struktur																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
strIO_GHdshk_Riem2.b_ExterneBahn						:= FALSE;
strIO_GHdshk_Riem2.b_LiAnfang							:= fbEntprellenAnfang_Riem2.OsSensor;
strIO_GHdshk_Riem2.b_SwAnfang							:= bSwAnfang_Riem2;
strIO_GHdshk_Riem2.b_LiVorAnfang						:= fbEntprellenVorAnfang_Riem2.OsSensor;
strIO_GHdshk_Riem2.b_SwVorAnfang						:= bSwVorAnfang_Riem2;
strIO_GHdshk_Riem2.b_LiEnde							:= fbEntprellenEnde_Riem2.OsSensor;
strIO_GHdshk_Riem2.b_SwEnde							:= bSwEnde_Riem2;
strIO_GHdshk_Riem2.b_LiVorEnde						:= fbEntprellenVorEnde_Riem2.OsSensor;
strIO_GHdshk_Riem2.b_SwVorEnde						:= bSwVorEnde_Riem2;
strIO_GHdshk_Riem2.b_LiBelegtkontrolle					:= fbEntprellenBelegtkontrolle_Riem2.OsSensor;
strIO_GHdshk_Riem2.b_BahnIstAufFoerderhoehe				:= fbBahn_Riem2.IsBahnIstAufFoerderhoehe;
strIO_GHdshk_Riem2.b_BahnVor							:= fbRampe_Riem2.bQ_MovePos;
strIO_GHdshk_Riem2.b_BahnZurueck						:= fbRampe_Riem2.bQ_MoveNeg;
strIO_GHdshk_Riem2.b_BahnSteht						:= fbRampe_Riem2.bQ_MoveNot;
strIO_GHdshk_Riem2.b_FreimeldungAnNachSektion				:= fbBahn_Riem2.OsFreimeldungAnNachSektion
												AND ( strIO_GHdshk_Riem2_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnRuecklauf
													OR	strIO_GHdshk_Riem2_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnPosiRuecklauf
													OR	strIO_GHdshk_Riem2_Nachf.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem2_Nachf.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem2_Nachf.b_ExterneBahn
													OR	bI_NachfRiemHatNurEineSpur );
strIO_GHdshk_Riem2.b_FreimeldungAnVorSektion				:= fbBahn_Riem2.OsFreimeldungAnVorSektion
												AND ( strIO_GHdshk_Riem2_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnVorlauf
													OR	strIO_GHdshk_Riem2_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnPosiVorlauf
													OR	strIO_GHdshk_Riem2_Vorg.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Riem2_Vorg.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Riem2_Vorg.b_ExterneBahn
													OR	bI_VorgRiemHatNurEineSpur );
strIO_GHdshk_Riem2.b_VerstandenPlatteAbgelegt				:= fbBahn_Riem2.OsVerstandenLaderPlatteAbgelegt;
strIO_GHdshk_Riem2.b_VerstandenPlatteGeholt				:= fbBahn_Riem2.OsVerstandenLaderPlatteGeholt;
strIO_GHdshk_Riem2.i_AblaufStatus_AufBahn					:= fbBahn_Riem2.OwAblaufStatus_AufBahn;
strIO_GHdshk_Riem2.i_AblaufStatus_VonBahn					:= fbBahn_Riem2.OwAblaufStatus_VonBahn;
strIO_GHdshk_Riem2.str_BahnStatus						:= fbBahn_Riem2.OwBahnStatus;
strIO_GHdshk_Riem2.str_JobAktiv_AufBahn					:= fbBahn_Riem2.OwJobAktiv_AufBahn;
strIO_GHdshk_Riem2.str_JobAktiv_VonBahn					:= fbBahn_Riem2.OwJobAktiv_VonBahn;
strIO_GHdshk_Riem2.b_MBahnBelegt_KeineDaten				:= fbBahn_Riem2.OsMBahnBelegt_KeineDaten;
strIO_GHdshk_Riem2.b_MBahnFrei_Daten					:= fbBahn_Riem2.OsMBahnFrei_Daten;
strIO_GHdshk_Riem2.b_MBahnNichtAufFoerderhoehe				:= fbBahn_Riem2.OsMBahnNichtAufFoerderhoehe;
strIO_GHdshk_Riem2.b_MMaxLaufzeit_AufBahn					:= fbBahn_Riem2.OsMMaxLaufzeit_AufBahn;
strIO_GHdshk_Riem2.b_MMaxLaufzeit_VonBahn					:= fbBahn_Riem2.OsMMaxLaufzeit_VonBahn;
strIO_GHdshk_Riem2.b_MStoerungAntrieb					:= fbBahn_Riem2.OsMStoerungAntrieb;
strIO_GHdshk_Riem2.b_MKeineFreigabe_FahrtInGrund			:= fbBahn_Riem2.OsMKeineFreigabe_FahrtInGrund;
strIO_GHdshk_Riem2.b_MFehlerRegisterimpuls				:= fbGeberKontrolle_Riem2.bQ_FehlerGeber;
strIO_GHdshk_Riem2.b_MFehlerSkalierung					:= fbGeberKontrolle_Riem2.bQ_FehlerSkalierung;

strIO_GHdshk_Riem2.b_GeberHandling_AufBahn_Aktiv			:= fbGeberHandling_AufBahn_Riem2.OsAktiv;
strIO_GHdshk_Riem2.b_GeberHandling_AufBahn_Fertig			:= fbGeberHandling_AufBahn_Riem2.OsFertig;
strIO_GHdshk_Riem2.r_PosiRestwert_AufBahn					:= fbGeberHandling_AufBahn_Riem2.OwPosiRestWert;

strIO_GHdshk_Riem2.b_GeberHandling_VonBahn_Aktiv			:= fbGeberHandling_VonBahn_Riem2.OsAktiv;
strIO_GHdshk_Riem2.b_GeberHandling_VonBahn_Fertig			:= fbGeberHandling_VonBahn_Riem2.OsFertig;
strIO_GHdshk_Riem2.r_PosiRestwert_VonBahn					:= fbGeberHandling_VonBahn_Riem2.OwPosiRestWert;

IF	fbRampe_Riem2.bI_Couple
THEN
	strIO_GHdshk_Riem2.lr_Bahnspeed_Soll				:= fbRampe_Riem2.lrI_CoupleVelocity;
ELSE
	strIO_GHdshk_Riem2.lr_Bahnspeed_Soll				:= fbRampe_Riem2.lrI_Velocity;
END_IF;

strIO_GHdshk_Riem2.lr_Bahnspeed_Vorgabe					:= fbRampe_Riem2.lrQ_ActVelocity;

IF	( strIO_GHdshk_Riem2.b_LiAnfang
	AND	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn <> eRolljobAufBahnVorlauf
	AND	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn <> eRolljobAufBahnPosiVorlauf
	AND	strIO_GHdshk_Riem2.b_BahnVor
	OR	strIO_GHdshk_Riem2.b_LiEnde
		AND	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn <> eRolljobAufBahnRuecklauf
		AND	strIO_GHdshk_Riem2.str_JobAktiv_AufBahn <> eRolljobAufBahnPosiRuecklauf
		AND	strIO_GHdshk_Riem2.b_BahnZurueck )
	AND NOT strIO_GHdshk_Riem2.b_MTeilNichtFreigegeben
	AND NOT strIO_GLmHand.bI_QuittStoerung
	AND	bI_Automatik
	AND	bI_MitUeberwachungTeilNichtFreigegeben
THEN
	strIO_GHdshk_Riem2.b_MTeilNichtFreigegeben:= TRUE;

ELSIF	strIO_GLmHand.bI_QuittStoerung
THEN
	strIO_GHdshk_Riem2.b_MTeilNichtFreigegeben:= FALSE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Y_Struktur_Roll1" Id="{de73598c-2fd8-439a-b44d-b5eaab3ca7c3}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Struktur																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
strIO_GHdshk_Roll1.b_ExterneBahn						:= FALSE;
strIO_GHdshk_Roll1.b_LiAnfang							:= fbEntprellenAnfang_Roll1.OsSensor;
strIO_GHdshk_Roll1.b_SwAnfang							:= bSwAnfang_Roll1;
strIO_GHdshk_Roll1.b_LiVorAnfang						:= fbEntprellenVorAnfang_Roll1.OsSensor;
strIO_GHdshk_Roll1.b_SwVorAnfang						:= bSwVorAnfang_Roll1;
strIO_GHdshk_Roll1.b_LiEnde							:= fbEntprellenEnde_Roll1.OsSensor;
strIO_GHdshk_Roll1.b_SwEnde							:= bSwEnde_Roll1;
strIO_GHdshk_Roll1.b_LiVorEnde						:= fbEntprellenVorEnde_Roll1.OsSensor;
strIO_GHdshk_Roll1.b_SwVorEnde						:= bSwVorEnde_Roll1;
strIO_GHdshk_Roll1.b_LiBelegtkontrolle					:= fbEntprellenBelegtkontrolle_Roll1.OsSensor;
strIO_GHdshk_Roll1.b_BahnIstAufFoerderhoehe				:= fbBahn_Roll1.IsBahnIstAufFoerderhoehe;
strIO_GHdshk_Roll1.b_BahnVor							:= fbRampe_Roll1.bQ_MovePos;
strIO_GHdshk_Roll1.b_BahnZurueck						:= fbRampe_Roll1.bQ_MoveNeg;
strIO_GHdshk_Roll1.b_BahnSteht						:= fbRampe_Roll1.bQ_MoveNot;
strIO_GHdshk_Roll1.b_FreimeldungAnNachSektion				:= fbBahn_Roll1.OsFreimeldungAnNachSektion
												AND ( strIO_GHdshk_Roll1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnRuecklauf
													OR	strIO_GHdshk_Roll1_Nachf.str_JobAktiv_VonBahn = eRollJobVonBahnPosiRuecklauf
													OR	strIO_GHdshk_Roll1_Nachf.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Roll1_Nachf.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Roll1_Nachf.b_ExterneBahn );
strIO_GHdshk_Roll1.b_FreimeldungAnVorSektion				:= fbBahn_Roll1.OsFreimeldungAnVorSektion
												AND ( strIO_GHdshk_Roll1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnVorlauf
													OR	strIO_GHdshk_Roll1_Vorg.str_JobAktiv_VonBahn = eRollJobVonBahnPosiVorlauf
													OR	strIO_GHdshk_Roll1_Vorg.b_SektionenKoppelnInX
													OR	strIO_GHdshk_Roll1_Vorg.b_SektionenKoppelnInY
													OR	strIO_GHdshk_Roll1_Vorg.b_ExterneBahn );
strIO_GHdshk_Roll1.b_VerstandenPlatteAbgelegt				:= fbBahn_Roll1.OsVerstandenLaderPlatteAbgelegt;
strIO_GHdshk_Roll1.b_VerstandenPlatteGeholt				:= fbBahn_Roll1.OsVerstandenLaderPlatteGeholt;
strIO_GHdshk_Roll1.i_AblaufStatus_AufBahn					:= fbBahn_Roll1.OwAblaufStatus_AufBahn;
strIO_GHdshk_Roll1.i_AblaufStatus_VonBahn					:= fbBahn_Roll1.OwAblaufStatus_VonBahn;
strIO_GHdshk_Roll1.str_BahnStatus						:= fbBahn_Roll1.OwBahnStatus;
strIO_GHdshk_Roll1.str_JobAktiv_AufBahn					:= fbBahn_Roll1.OwJobAktiv_AufBahn;
strIO_GHdshk_Roll1.str_JobAktiv_VonBahn					:= fbBahn_Roll1.OwJobAktiv_VonBahn;
strIO_GHdshk_Roll1.b_MBahnBelegt_KeineDaten				:= fbBahn_Roll1.OsMBahnBelegt_KeineDaten;
strIO_GHdshk_Roll1.b_MBahnFrei_Daten					:= fbBahn_Roll1.OsMBahnFrei_Daten;
strIO_GHdshk_Roll1.b_MBahnNichtAufFoerderhoehe				:= fbBahn_Roll1.OsMBahnNichtAufFoerderhoehe;
strIO_GHdshk_Roll1.b_MMaxLaufzeit_AufBahn					:= fbBahn_Roll1.OsMMaxLaufzeit_AufBahn;
strIO_GHdshk_Roll1.b_MMaxLaufzeit_VonBahn					:= fbBahn_Roll1.OsMMaxLaufzeit_VonBahn;
strIO_GHdshk_Roll1.b_MStoerungAntrieb					:= fbBahn_Roll1.OsMStoerungAntrieb;
strIO_GHdshk_Roll1.b_MKeineFreigabe_FahrtInGrund			:= fbBahn_Roll1.OsMKeineFreigabe_FahrtInGrund;
strIO_GHdshk_Roll1.b_MFehlerRegisterimpuls				:= fbGeberKontrolle_Roll1.bQ_FehlerGeber;
strIO_GHdshk_Roll1.b_MFehlerSkalierung					:= fbGeberKontrolle_Roll1.bQ_FehlerSkalierung;

strIO_GHdshk_Roll1.b_GeberHandling_AufBahn_Aktiv			:= fbGeberHandling_AufBahn_Roll1.OsAktiv;
strIO_GHdshk_Roll1.b_GeberHandling_AufBahn_Fertig			:= fbGeberHandling_AufBahn_Roll1.OsFertig;
strIO_GHdshk_Roll1.r_PosiRestwert_AufBahn					:= fbGeberHandling_AufBahn_Roll1.OwPosiRestWert;

strIO_GHdshk_Roll1.b_GeberHandling_VonBahn_Aktiv			:= fbGeberHandling_VonBahn_Roll1.OsAktiv;
strIO_GHdshk_Roll1.b_GeberHandling_VonBahn_Fertig			:= fbGeberHandling_VonBahn_Roll1.OsFertig;
strIO_GHdshk_Roll1.r_PosiRestwert_VonBahn					:= fbGeberHandling_VonBahn_Roll1.OwPosiRestWert;

IF	fbRampe_Roll1.bI_Couple
THEN
	strIO_GHdshk_Roll1.lr_Bahnspeed_Soll				:= fbRampe_Roll1.lrI_CoupleVelocity;
ELSE
	strIO_GHdshk_Roll1.lr_Bahnspeed_Soll				:= fbRampe_Roll1.lrI_Velocity;
END_IF;

strIO_GHdshk_Roll1.lr_Bahnspeed_Vorgabe					:= fbRampe_Roll1.lrQ_ActVelocity;

IF	( strIO_GHdshk_Roll1.b_LiAnfang
	AND	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn <> eRolljobAufBahnVorlauf
	AND	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn <> eRolljobAufBahnPosiVorlauf
	AND	strIO_GHdshk_Roll1.b_BahnVor
	OR	strIO_GHdshk_Roll1.b_LiEnde
		AND	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn <> eRolljobAufBahnRuecklauf
		AND	strIO_GHdshk_Roll1.str_JobAktiv_AufBahn <> eRolljobAufBahnPosiRuecklauf
		AND	strIO_GHdshk_Roll1.b_BahnZurueck )
	AND NOT strIO_GHdshk_Roll1.b_MTeilNichtFreigegeben
	AND NOT strIO_GLmHand.bI_QuittStoerung
	AND	bI_Automatik
	AND	bI_MitUeberwachungTeilNichtFreigegeben
THEN
	strIO_GHdshk_Roll1.b_MTeilNichtFreigegeben:= TRUE;

ELSIF	strIO_GLmHand.bI_QuittStoerung
THEN
	strIO_GHdshk_Roll1.b_MTeilNichtFreigegeben:= FALSE;
END_IF;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Z_Meldungen_Riem1" Id="{582af093-c6e3-47ec-8a4e-4570155b47dd}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Meldungen																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

(*0-4 Störung Antriebe*)
OfMeldung[uiI_FehlerId_Riem1+0]:= strIO_GHdshk_Riem1.b_MStoerungAntrieb;
OfMeldung[uiI_FehlerId_Riem1+1]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+2]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+3]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+4]:= FALSE;

(*5-9 Fehler Absoluter Stop*)
OfMeldung[uiI_FehlerId_Riem1+5]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+6]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+7]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+8]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+9]:= FALSE;

(*10-19 Fehler Bedingter Stop*)
OfMeldung[uiI_FehlerId_Riem1+10]:= fbRampe_Riem1.bQ_Error
						AND 	fbRampe_Riem1.uiQ_ErrorNumber = 100;
OfMeldung[uiI_FehlerId_Riem1+11]:= fbRampe_Riem1.bQ_Error
						AND 	fbRampe_Riem1.uiQ_ErrorNumber = 101;
OfMeldung[uiI_FehlerId_Riem1+12]:= fbRampe_Riem1.bQ_Error
						AND 	fbRampe_Riem1.uiQ_ErrorNumber = 102;
OfMeldung[uiI_FehlerId_Riem1+13]:= fbRampe_Riem1.bQ_Error
						AND 	fbRampe_Riem1.uiQ_ErrorNumber = 103;
OfMeldung[uiI_FehlerId_Riem1+14]:= fbRampe_Riem1.bQ_Error
						AND 	fbRampe_Riem1.uiQ_ErrorNumber = 104;
OfMeldung[uiI_FehlerId_Riem1+15]:= fbRampe_Riem1.bQ_Error
						AND 	fbRampe_Riem1.uiQ_ErrorNumber = 105;
OfMeldung[uiI_FehlerId_Riem1+16]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+17]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+18]:= FALSE;

IF	uiI_AxId_Riem1 > 0
THEN
	OfMeldung[uiI_FehlerId_Riem1+19]:= NOT AxFrNcGeeicht[uiI_AxId_Riem1];
ELSE
	OfMeldung[uiI_FehlerId_Riem1+19]:= FALSE;
END_IF;

(*20-34 Fehler Mit Quittierung*)
OfMeldung[uiI_FehlerId_Riem1+20]:= strIO_GHdshk_Riem1.b_MMaxLaufzeit_AufBahn;
OfMeldung[uiI_FehlerId_Riem1+21]:= strIO_GHdshk_Riem1.b_MMaxLaufzeit_VonBahn;
OfMeldung[uiI_FehlerId_Riem1+22]:= strIO_GHdshk_Riem1.b_MBahnNichtAufFoerderhoehe;
OfMeldung[uiI_FehlerId_Riem1+23]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+24]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+25]:= strIO_GHdshk_Riem1.b_MBahnBelegt_KeineDaten;
OfMeldung[uiI_FehlerId_Riem1+26]:= strIO_GHdshk_Riem1.b_MBahnFrei_Daten;
OfMeldung[uiI_FehlerId_Riem1+27]:= strIO_GHdshk_Riem1.b_MFehlerRegisterimpuls;
OfMeldung[uiI_FehlerId_Riem1+28]:= strIO_GHdshk_Riem1.b_MKeineFreigabe_FahrtInGrund;
OfMeldung[uiI_FehlerId_Riem1+29]:= strIO_GHdshk_Riem1.b_MTeilNichtFreigegeben;
OfMeldung[uiI_FehlerId_Riem1+30]:= strIO_GHdshk_Riem1.b_MFehlerSkalierung;
OfMeldung[uiI_FehlerId_Riem1+31]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+32]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+33]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+34]:= FALSE;

(*35-49 Fehler ohne Quittierung*)
OfMeldung[uiI_FehlerId_Riem1+35]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+36]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+37]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+38]:= FALSE;	
OfMeldung[uiI_FehlerId_Riem1+39]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+40]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+41]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+42]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+43]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+44]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+45]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+46]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+47]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+48]:= FALSE;
OfMeldung[uiI_FehlerId_Riem1+49]:= FALSE;

strIO_Stoerungen.bStoerungAntriebe:=
	strIO_Stoerungen.bStoerungAntriebe
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem1, Bis:= uiI_FehlerId_Riem1 + 4, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bAbsoluterStop:=
	strIO_Stoerungen.bAbsoluterStop
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem1 + 5, Bis:= uiI_FehlerId_Riem1 + 9, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bBedingterStop:=
	strIO_Stoerungen.bBedingterStop
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem1 + 10, Bis:= uiI_FehlerId_Riem1 + 19, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bFehlerMitQuittung:=
	strIO_Stoerungen.bFehlerMitQuittung
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem1 + 20, Bis:= uiI_FehlerId_Riem1 + 34, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bFehlerOhneQuittung:=
	strIO_Stoerungen.bFehlerOhneQuittung
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem1 + 35, Bis:= uiI_FehlerId_Riem1 + 49, Anzahl:= 0, Raster:= 0 );]]></ST>
      </Implementation>
    </Action>
    <Action Name="Z_Meldungen_Riem2" Id="{41597f38-74ea-47cb-a99b-bef50e80316b}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Meldungen																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

(*0-4 Störung Antriebe*)
OfMeldung[uiI_FehlerId_Riem2+0]:= strIO_GHdshk_Riem2.b_MStoerungAntrieb;
OfMeldung[uiI_FehlerId_Riem2+1]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+2]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+3]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+4]:= FALSE;

(*5-9 Fehler Absoluter Stop*)
OfMeldung[uiI_FehlerId_Riem2+5]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+6]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+7]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+8]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+9]:= FALSE;

(*10-19 Fehler Bedingter Stop*)
OfMeldung[uiI_FehlerId_Riem2+10]:= fbRampe_Riem2.bQ_Error
						AND 	fbRampe_Riem2.uiQ_ErrorNumber = 100;
OfMeldung[uiI_FehlerId_Riem2+11]:= fbRampe_Riem2.bQ_Error
						AND 	fbRampe_Riem2.uiQ_ErrorNumber = 101;
OfMeldung[uiI_FehlerId_Riem2+12]:= fbRampe_Riem2.bQ_Error
						AND 	fbRampe_Riem2.uiQ_ErrorNumber = 102;
OfMeldung[uiI_FehlerId_Riem2+13]:= fbRampe_Riem2.bQ_Error
						AND 	fbRampe_Riem2.uiQ_ErrorNumber = 103;
OfMeldung[uiI_FehlerId_Riem2+14]:= fbRampe_Riem2.bQ_Error
						AND 	fbRampe_Riem2.uiQ_ErrorNumber = 104;
OfMeldung[uiI_FehlerId_Riem2+15]:= fbRampe_Riem2.bQ_Error
						AND 	fbRampe_Riem2.uiQ_ErrorNumber = 105;
OfMeldung[uiI_FehlerId_Riem2+16]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+17]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+18]:= FALSE;

IF	uiI_AxId_Riem2 > 0
THEN
	OfMeldung[uiI_FehlerId_Riem2+19]:= NOT AxFrNcGeeicht[uiI_AxId_Riem2];
ELSE
	OfMeldung[uiI_FehlerId_Riem2+19]:= FALSE;
END_IF;

(*20-34 Fehler Mit Quittierung*)
OfMeldung[uiI_FehlerId_Riem2+20]:= strIO_GHdshk_Riem2.b_MMaxLaufzeit_AufBahn;
OfMeldung[uiI_FehlerId_Riem2+21]:= strIO_GHdshk_Riem2.b_MMaxLaufzeit_VonBahn;
OfMeldung[uiI_FehlerId_Riem2+22]:= strIO_GHdshk_Riem2.b_MBahnNichtAufFoerderhoehe;
OfMeldung[uiI_FehlerId_Riem2+23]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+24]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+25]:= strIO_GHdshk_Riem2.b_MBahnBelegt_KeineDaten;
OfMeldung[uiI_FehlerId_Riem2+26]:= strIO_GHdshk_Riem2.b_MBahnFrei_Daten;
OfMeldung[uiI_FehlerId_Riem2+27]:= strIO_GHdshk_Riem2.b_MFehlerRegisterimpuls;
OfMeldung[uiI_FehlerId_Riem2+28]:= strIO_GHdshk_Riem2.b_MKeineFreigabe_FahrtInGrund;
OfMeldung[uiI_FehlerId_Riem2+29]:= strIO_GHdshk_Riem2.b_MTeilNichtFreigegeben;
OfMeldung[uiI_FehlerId_Riem2+30]:= strIO_GHdshk_Riem2.b_MFehlerSkalierung;
OfMeldung[uiI_FehlerId_Riem2+31]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+32]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+33]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+34]:= FALSE;

(*35-49 Fehler ohne Quittierung*)
OfMeldung[uiI_FehlerId_Riem2+35]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+36]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+37]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+38]:= FALSE;	
OfMeldung[uiI_FehlerId_Riem2+39]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+40]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+41]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+42]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+43]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+44]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+45]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+46]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+47]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+48]:= FALSE;
OfMeldung[uiI_FehlerId_Riem2+49]:= FALSE;

strIO_Stoerungen.bStoerungAntriebe:=
	strIO_Stoerungen.bStoerungAntriebe
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem2, Bis:= uiI_FehlerId_Riem2 + 4, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bAbsoluterStop:=
	strIO_Stoerungen.bAbsoluterStop
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem2 + 5, Bis:= uiI_FehlerId_Riem2 + 9, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bBedingterStop:=
	strIO_Stoerungen.bBedingterStop
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem2 + 10, Bis:= uiI_FehlerId_Riem2 + 19, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bFehlerMitQuittung:=
	strIO_Stoerungen.bFehlerMitQuittung
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem2 + 20, Bis:= uiI_FehlerId_Riem2 + 34, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bFehlerOhneQuittung:=
	strIO_Stoerungen.bFehlerOhneQuittung
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Riem2 + 35, Bis:= uiI_FehlerId_Riem2 + 49, Anzahl:= 0, Raster:= 0 );]]></ST>
      </Implementation>
    </Action>
    <Action Name="Z_Meldungen_Roll1" Id="{e8fb436d-dd1e-4e9d-89e1-6145f1002133}">
      <Implementation>
        <ST><![CDATA[(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*                Meldungen																		*)
(*----------------------------------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------------------------------------*)

(*0-4 Störung Antriebe*)
OfMeldung[uiI_FehlerId_Roll1+0]:= strIO_GHdshk_Roll1.b_MStoerungAntrieb;
OfMeldung[uiI_FehlerId_Roll1+1]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+2]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+3]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+4]:= FALSE;

(*5-9 Fehler Absoluter Stop*)
OfMeldung[uiI_FehlerId_Roll1+5]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+6]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+7]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+8]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+9]:= FALSE;

(*10-19 Fehler Bedingter Stop*)
OfMeldung[uiI_FehlerId_Roll1+10]:= fbRampe_Roll1.bQ_Error
						AND 	fbRampe_Roll1.uiQ_ErrorNumber = 100;
OfMeldung[uiI_FehlerId_Roll1+11]:= fbRampe_Roll1.bQ_Error
						AND 	fbRampe_Roll1.uiQ_ErrorNumber = 101;
OfMeldung[uiI_FehlerId_Roll1+12]:= fbRampe_Roll1.bQ_Error
						AND 	fbRampe_Roll1.uiQ_ErrorNumber = 102;
OfMeldung[uiI_FehlerId_Roll1+13]:= fbRampe_Roll1.bQ_Error
						AND 	fbRampe_Roll1.uiQ_ErrorNumber = 103;
OfMeldung[uiI_FehlerId_Roll1+14]:= fbRampe_Roll1.bQ_Error
						AND 	fbRampe_Roll1.uiQ_ErrorNumber = 104;
OfMeldung[uiI_FehlerId_Roll1+15]:= fbRampe_Roll1.bQ_Error
						AND 	fbRampe_Roll1.uiQ_ErrorNumber = 105;
OfMeldung[uiI_FehlerId_Roll1+16]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+17]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+18]:= FALSE;

IF	uiI_AxId_Roll1 > 0
THEN
	OfMeldung[uiI_FehlerId_Roll1+19]:= NOT AxFrNcGeeicht[uiI_AxId_Roll1];
ELSE
	OfMeldung[uiI_FehlerId_Roll1+19]:= FALSE;
END_IF;

(*20-34 Fehler Mit Quittierung*)
OfMeldung[uiI_FehlerId_Roll1+20]:= strIO_GHdshk_Roll1.b_MMaxLaufzeit_AufBahn;
OfMeldung[uiI_FehlerId_Roll1+21]:= strIO_GHdshk_Roll1.b_MMaxLaufzeit_VonBahn;
OfMeldung[uiI_FehlerId_Roll1+22]:= strIO_GHdshk_Roll1.b_MBahnNichtAufFoerderhoehe;
OfMeldung[uiI_FehlerId_Roll1+23]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+24]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+25]:= strIO_GHdshk_Roll1.b_MBahnBelegt_KeineDaten;
OfMeldung[uiI_FehlerId_Roll1+26]:= strIO_GHdshk_Roll1.b_MBahnFrei_Daten;
OfMeldung[uiI_FehlerId_Roll1+27]:= strIO_GHdshk_Roll1.b_MFehlerRegisterimpuls;
OfMeldung[uiI_FehlerId_Roll1+28]:= strIO_GHdshk_Roll1.b_MKeineFreigabe_FahrtInGrund;
OfMeldung[uiI_FehlerId_Roll1+29]:= strIO_GHdshk_Roll1.b_MTeilNichtFreigegeben;
OfMeldung[uiI_FehlerId_Roll1+30]:= strIO_GHdshk_Roll1.b_MFehlerSkalierung;
OfMeldung[uiI_FehlerId_Roll1+31]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+32]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+33]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+34]:= FALSE;

(*35-49 Fehler ohne Quittierung*)
OfMeldung[uiI_FehlerId_Roll1+35]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+36]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+37]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+38]:= FALSE;	
OfMeldung[uiI_FehlerId_Roll1+39]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+40]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+41]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+42]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+43]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+44]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+45]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+46]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+47]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+48]:= FALSE;
OfMeldung[uiI_FehlerId_Roll1+49]:= FALSE;

strIO_Stoerungen.bStoerungAntriebe:=
	strIO_Stoerungen.bStoerungAntriebe
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Roll1, Bis:= uiI_FehlerId_Roll1 + 4, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bAbsoluterStop:=
	strIO_Stoerungen.bAbsoluterStop
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Roll1 + 5, Bis:= uiI_FehlerId_Roll1 + 9, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bBedingterStop:=
	strIO_Stoerungen.bBedingterStop
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Roll1 + 10, Bis:= uiI_FehlerId_Roll1 + 19, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bFehlerMitQuittung:=
	strIO_Stoerungen.bFehlerMitQuittung
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Roll1 + 20, Bis:= uiI_FehlerId_Roll1 + 34, Anzahl:= 0, Raster:= 0 );

strIO_Stoerungen.bFehlerOhneQuittung:=
	strIO_Stoerungen.bFehlerOhneQuittung
	OR	F_MeldungAktiv( Von:= uiI_FehlerId_Roll1 + 35, Bis:= uiI_FehlerId_Roll1 + 49, Anzahl:= 0, Raster:= 0 );]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem">
      <LineId Id="209" Count="212" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.A_Bahnmodi_Riem1">
      <LineId Id="0" Count="85" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.A_Bahnmodi_Riem2">
      <LineId Id="0" Count="97" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.A_Bahnmodi_Roll1">
      <LineId Id="0" Count="93" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.B_Zeiten_Rampen_Speed_Riem1">
      <LineId Id="0" Count="114" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.B_Zeiten_Rampen_Speed_Riem2">
      <LineId Id="0" Count="148" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.B_Zeiten_Rampen_Speed_Roll1">
      <LineId Id="0" Count="115" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.C_Eingaenge_Riem1">
      <LineId Id="0" Count="257" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.C_Eingaenge_Riem2">
      <LineId Id="0" Count="289" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.C_Eingaenge_Roll1">
      <LineId Id="0" Count="254" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.D_Bahnjob_Riem1">
      <LineId Id="0" Count="32" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.D_Bahnjob_Riem2">
      <LineId Id="0" Count="32" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.D_Bahnjob_Roll1">
      <LineId Id="0" Count="32" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.E_Ausgaenge_Hub">
      <LineId Id="0" Count="161" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.E_Ausgaenge_Riem1">
      <LineId Id="0" Count="37" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.E_Ausgaenge_Riem2">
      <LineId Id="0" Count="37" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.E_Ausgaenge_Roll1">
      <LineId Id="0" Count="38" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.F_Positionierung_Riem1">
      <LineId Id="0" Count="217" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.F_Positionierung_Riem2">
      <LineId Id="0" Count="217" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.F_Positionierung_Roll1">
      <LineId Id="0" Count="217" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.G_Protokoll_Riem1">
      <LineId Id="0" Count="66" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.G_Protokoll_Riem2">
      <LineId Id="0" Count="66" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.G_Protokoll_Roll1">
      <LineId Id="0" Count="66" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.H_Funktionsauswertung_Riem1">
      <LineId Id="0" Count="164" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.H_Funktionsauswertung_Riem2">
      <LineId Id="0" Count="164" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.H_Funktionsauswertung_Roll1">
      <LineId Id="0" Count="165" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.H_Funktionsauswertung_Verriegelung">
      <LineId Id="0" Count="30" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.I_TrEstati_Diagnose">
      <LineId Id="0" Count="223" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.Y_Struktur_Riem1">
      <LineId Id="0" Count="142" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.Y_Struktur_Riem2">
      <LineId Id="0" Count="85" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.Y_Struktur_Roll1">
      <LineId Id="0" Count="83" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.Z_Meldungen_Riem1">
      <LineId Id="0" Count="96" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.Z_Meldungen_Riem2">
      <LineId Id="0" Count="96" />
    </LineIds>
    <LineIds Name="FB_Bahnhardware_Winkel_1Roll_2Riem.Z_Meldungen_Roll1">
      <LineId Id="0" Count="96" />
    </LineIds>
  </POU>
</TcPlcObject>